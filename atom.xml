<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>金若愚的blog</title>
  
  <subtitle>你好</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hzjry123.github.io/"/>
  <updated>2018-03-28T04:09:41.485Z</updated>
  <id>https://hzjry123.github.io/</id>
  
  <author>
    <name>金若愚</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>文本数据挖掘</title>
    <link href="https://hzjry123.github.io/2018/03/27/text-mining/"/>
    <id>https://hzjry123.github.io/2018/03/27/text-mining/</id>
    <published>2018-03-27T14:09:20.000Z</published>
    <updated>2018-03-28T04:09:41.485Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Goal"><a href="#Goal" class="headerlink" title="Goal:"></a>Goal:</h2><p> extracting information from a usually large amount of different unstructured textual resources. <strong>Turn unstructured to structured data.</strong></p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><h3 id="remove-stopwords"><a href="#remove-stopwords" class="headerlink" title="remove stopwords:"></a>remove stopwords:</h3><p>stopwords: frequently occuring and insignificant words. </p><ul><li>a, about, an, are, as…. is, in, of.</li></ul><h3 id="stemming"><a href="#stemming" class="headerlink" title="stemming"></a>stemming</h3><p>reduce words to their stems or roots.</p><p>e.g. computer, computing, compute-&gt; comput</p><p>Walks, walker -&gt; walk</p><h3 id="Other-pre-processing-tasks"><a href="#Other-pre-processing-tasks" class="headerlink" title="Other pre-processing tasks:"></a>Other pre-processing tasks:</h3><p>Digits removed, hyhens, punctuation marks</p><h3 id="Web-Page-Pre-Processing"><a href="#Web-Page-Pre-Processing" class="headerlink" title="Web Page Pre-Processing"></a>Web Page Pre-Processing</h3><p>针对html不同的部分, \<title>, \<body>, \<h1>…分配不同的重要性。</h1></body></title></p><p>超链接，超链接代表的内容往往代表了更准确的描述。</p><p>移除html tags</p><h2 id="Feature-re-weighting"><a href="#Feature-re-weighting" class="headerlink" title="Feature re-weighting"></a>Feature re-weighting</h2><p>并不是所有的词汇是一样重要的，在文档中出现更多的词汇可能相对就缺少discriminatory power。</p><p>处理方式： <strong>inverse-document frequency</strong></p><script type="math/tex; mode=display">IDF = log\frac{n}{d_j}</script><p>$n$: number of documents</p><p>$d_j$: number of documents containing word j.</p><p>$Term importance = TF * IDF$</p><script type="math/tex; mode=display">tf-idf = f_{ij}\times log(\frac{n}{d_j})</script><p>$f_{ij}$: term frequency, the relative frequency of word j in document i.</p><h2 id="Vector-Space-Model"><a href="#Vector-Space-Model" class="headerlink" title="Vector Space Model"></a>Vector Space Model</h2><p>Corpus(语料库), a set of N documents</p><ul><li>D =$ {d1,…,dn}$</li></ul><p>Vocabulary, a set of M words</p><ul><li>W =${w1,…,w_m}$</li></ul><p>$M \times N$的矩阵代表了words的频率</p><p>有些词在所有文档里出现很多，但是有的词只在一些文档里出现很多，$tf-idf$就是要惩罚这些出现很多的词。</p><h3 id="Query-和-document的相似性计算"><a href="#Query-和-document的相似性计算" class="headerlink" title="Query 和 document的相似性计算"></a>Query 和 document的相似性计算</h3><p>余弦相似度: $cos(q,d) = \frac{q^T}{||q||\space ||d||}$</p><p>Limitation: </p><ul><li>维度过高</li><li>很稀疏，余弦相似度会不准确</li><li>捕捉不到语义关系，没有关注词汇的内在含义</li></ul><h1 id="Topic-Modeling"><a href="#Topic-Modeling" class="headerlink" title="Topic Modeling"></a>Topic Modeling</h1><p>LSA(Latent Semantic Analysis)</p><p>pLSA(probabilistic Latent Semantic Analysis)</p><p><strong>LDA(Latent Dirichlet Allocation)</strong></p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>words &lt;-&gt; topics(concepts) &lt;-&gt;documents</p><h2 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h2><h3 id="General-Idea"><a href="#General-Idea" class="headerlink" title="General Idea"></a>General Idea</h3><p>把文档从高维投影到低维，让低维空间反映语言关系，根据向量内积计算document similarity</p><h3 id="method：SVD"><a href="#method：SVD" class="headerlink" title="method：SVD"></a>method：SVD</h3><p><img src="/2018/03/27/text-mining/svd.png" alt=""></p><ul><li>给定一个term-document matrix X (m x n)，做奇异值分解。<ul><li>$X=U\sum V^T$</li><li>从$\sum$选择k大的奇异值，进行降维。</li></ul></li></ul><p><img src="/2018/03/27/text-mining/SVD stage.png" alt=""></p><h3 id="Concept-space"><a href="#Concept-space" class="headerlink" title="Concept space"></a>Concept space</h3><p>降维后我们相当于把原矩阵投影到concept space了，concept ~ topic</p><p><img src="/2018/03/27/text-mining/svd result.png" alt=""></p><p>左奇异向量相当于$term_i$在concept空间里的出现。</p><p>右奇异向量相当与$document_i$在concept空间里的出现。</p><h3 id="计算document-q和j的余弦相似度"><a href="#计算document-q和j的余弦相似度" class="headerlink" title="计算document q和j的余弦相似度"></a>计算document q和j的余弦相似度</h3><script type="math/tex; mode=display">d_j = U_k\sum k \hat d_j</script><script type="math/tex; mode=display">\hat d_j = {\sum }_k^{-1} U_k ^T d_j</script><h3 id="Pros-and-Cons"><a href="#Pros-and-Cons" class="headerlink" title="Pros and Cons"></a>Pros and Cons</h3><ul><li>Pros<ul><li>同义词可以被捕捉到</li><li>降维可以移除噪声</li></ul></li><li>Cons<ul><li>可能有负值，难以解释</li><li>一词多义问题无法被解决</li></ul></li></ul><h2 id="pLSA"><a href="#pLSA" class="headerlink" title="pLSA"></a>pLSA</h2><h2 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Goal&quot;&gt;&lt;a href=&quot;#Goal&quot; class=&quot;headerlink&quot; title=&quot;Goal:&quot;&gt;&lt;/a&gt;Goal:&lt;/h2&gt;&lt;p&gt; extracting information from a usually large amount of diffe
      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>quick sort</title>
    <link href="https://hzjry123.github.io/2018/03/22/quick-sort/"/>
    <id>https://hzjry123.github.io/2018/03/22/quick-sort/</id>
    <published>2018-03-22T14:35:14.000Z</published>
    <updated>2018-03-28T04:09:02.626Z</updated>
    
    <content type="html"><![CDATA[<p>今天复习了一下快排，感觉还是挺多收货的.</p><h1 id="快排的思想"><a href="#快排的思想" class="headerlink" title="快排的思想"></a>快排的思想</h1><p>快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。</p><p>该方法的基本思想是：</p><p>1．先从数列中取出一个数作为基准数pivot。</p><p>2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</p><p>3．再对左右区间重复第二步，直到各区间只有一个数。</p><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>根据以上的介绍，我写了最基础的快排（升序），即用最左边的元素作为pivot。在oj上过不了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksortbasic</span><span class="params">(<span class="keyword">int</span>[] put, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(put == <span class="keyword">null</span> || put.length &lt; <span class="number">2</span> || left &gt;= right)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="keyword">int</span> pivot = put[left];</span><br><span class="line">    <span class="keyword">while</span>(i != j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从右往左，找到比pivot小的第一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; put[j] &gt;= pivot)&#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从左往右，找到比pivot大的第一个元素</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; put[i] &lt;= pivot)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果存在这样的两个元素，则交换</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">            swap(put,i,j);</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//最后交换left和结束处的位置,即有几个比left小的</span></span><br><span class="line">    swap(put,left,i);</span><br><span class="line">    quicksortbasic(put, left, i - <span class="number">1</span>);</span><br><span class="line">    quicksortbasic(put, i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="挖坑法："><a href="#挖坑法：" class="headerlink" title="挖坑法："></a>挖坑法：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">wakengfa</span><span class="params">(<span class="keyword">int</span>[] put, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(put == <span class="keyword">null</span> || put.length &lt; <span class="number">2</span> || left &gt;= right)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">    <span class="comment">//如果想用中间的点作为pivot</span></span><br><span class="line">    <span class="comment">//swap(put,(left+right)/2,left);</span></span><br><span class="line">    <span class="comment">//对left处挖坑</span></span><br><span class="line">        <span class="keyword">int</span> pivot = put[left];</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="comment">//从右往左，找到比pivot小的第一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; put[j] &gt;= pivot)&#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有这样的j，则用新找到的j填坑</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                put[i] = put[j];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从左往右，找到比pivot大的第一个元素</span></span><br><span class="line">            <span class="keyword">while</span>(i &lt; j &amp;&amp; put[i] &lt;= pivot)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果有这样的i，则填上j的坑</span></span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)&#123;</span><br><span class="line">                put[j] = put[i];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//最后有i个比pivot小的元素。在put[i]处加入pivot      </span></span><br><span class="line">        put[i] = pivot;</span><br><span class="line">        wakengfa(put, left, i - <span class="number">1</span>);</span><br><span class="line">        wakengfa(put, i + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>对挖坑填数进行总结</p><p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p><p>2．j—由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p><p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p><p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中。</p><p>在挖坑法中，考虑到已经排序好的逆序数组（降序数组）会造成递归栈溢出的可能</p><p> {9，8，7，6，5，4，3，2，1，0} </p><p>第一次“填坑” 会变成 {0，8，7，6，5，4，3，2，1，0} </p><p>第一次结束：{0，8，7，6，5，4，3，2，1，9} </p><p>递归开始：</p><p>{0，8，7，6，5，4，3，2，1}  {9} </p><p>可以想见当数组长度很长的时候，是有可能会溢出的。因此一般会选择中间点或者是中位数作为pivot，保证递归两边数量差不多，效率最高。</p><h2 id="别的版本"><a href="#别的版本" class="headerlink" title="别的版本"></a>别的版本</h2><p>附上快排另一个版本，和挖坑法类似，但是比挖坑法难理解.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quicksortmiddle</span><span class="params">(<span class="keyword">int</span>[] put, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(right &lt;= left) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">int</span> i = left, j = right;</span><br><span class="line">     <span class="keyword">int</span> pivot = put[(right +left)/<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">while</span>(i &lt;= j)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span>(i &lt;= j &amp;&amp; put[i] &lt; pivot)&#123;</span><br><span class="line">             i++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(i &lt;= j &amp;&amp; put[j] &gt; pivot)&#123;</span><br><span class="line">             j--;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>(i &lt;= j)&#123;</span><br><span class="line">             swap(put,i++,j--);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    quicksortmiddle(put, left, j);</span><br><span class="line">    quicksortmiddle(put, i, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附上swap和调用代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSortenter</span><span class="params">(<span class="keyword">int</span>[] put)</span></span>&#123;</span><br><span class="line">        wakengfa(put,<span class="number">0</span>,put.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = input[a];</span><br><span class="line">        input[a] = input[b];</span><br><span class="line">        input[b] = temp;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Main函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> b[] = &#123;&#125;;</span><br><span class="line">        quickSortenter(a);</span><br><span class="line">        selectSort(b);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> element:</span><br><span class="line">             a) &#123;</span><br><span class="line">            System.out.print(element + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>reference：</p><p><a href="https://blog.csdn.net/morewindows/article/details/6684558" target="_blank" rel="noopener">https://blog.csdn.net/morewindows/article/details/6684558</a></p><p>测试oj：</p><p><a href="http://www.lintcode.com/zh-cn/problem/sort-integers-ii/#" target="_blank" rel="noopener">http://www.lintcode.com/zh-cn/problem/sort-integers-ii/#</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天复习了一下快排，感觉还是挺多收货的.&lt;/p&gt;
&lt;h1 id=&quot;快排的思想&quot;&gt;&lt;a href=&quot;#快排的思想&quot; class=&quot;headerlink&quot; title=&quot;快排的思想&quot;&gt;&lt;/a&gt;快排的思想&lt;/h1&gt;&lt;p&gt;快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。&lt;/p&gt;
&lt;p&gt;该方法的基本思想是：&lt;/p&gt;
&lt;p&gt;1．先从数列中取出一个数作为基准数pivot。&lt;/p&gt;
&lt;p&gt;2．分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。&lt;/p&gt;
&lt;p&gt;3．再对左右区间重复第二步，直到各区间只有一个数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://hzjry123.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Infromation Mid Term Review</title>
    <link href="https://hzjry123.github.io/2018/03/11/ir-review/"/>
    <id>https://hzjry123.github.io/2018/03/11/ir-review/</id>
    <published>2018-03-11T13:28:39.000Z</published>
    <updated>2018-03-20T16:02:45.277Z</updated>
    
    <content type="html"><![CDATA[<p>Information Retrieval的复习笔记，感觉最近忙到爆炸，春假了在图书馆发霉。真的爆炸！！</p><h1 id="1-Text-Processing"><a href="#1-Text-Processing" class="headerlink" title="1. Text Processing"></a>1. Text Processing</h1><h2 id="What-is-Bag-of-words-How-to-simplify-calculation"><a href="#What-is-Bag-of-words-How-to-simplify-calculation" class="headerlink" title="What is Bag of words? How to simplify calculation?"></a>What is Bag of words? How to simplify calculation?</h2><p><img src="/2018/03/11/ir-review/bag of words.png" alt=""></p><p>Bag of words is a collection of words appear in document. It assmume the word is independent with each other. Also it failed to recognize semantic relationship among words, it would not tell you synonyms words, hyponym and hypernym, homonyms. But we can tokenize each word unit for indexing, stemming.</p><a id="more"></a><h2 id="Remove-stop-words"><a href="#Remove-stop-words" class="headerlink" title="Remove stop words"></a>Remove stop words</h2><p>去除一些没用的词, the, a, an ….</p><h2 id="Lemmatization"><a href="#Lemmatization" class="headerlink" title="Lemmatization"></a>Lemmatization</h2><p>Reduce inflection/some derkvational variant forms to base form.</p><ul><li>Am,are,is -&gt; be</li><li>Car, car’s, car’s, cars’ -&gt; car</li></ul><p>works most on inflectional variants</p><p>合并一个单词的不同词形</p><h2 id="Stemming"><a href="#Stemming" class="headerlink" title="Stemming"></a>Stemming</h2><p>conflate morphological variants to their roots, called stems.</p><p><img src="/2018/03/11/ir-review/stem.png" alt=""></p><p>会去掉单词尾部的一些字母，合并形态上相似的词语，有同个词根的。</p><p>Works on derivational variants</p><h2 id="Why-stemming-is-better-than-lemmatization-gt"><a href="#Why-stemming-is-better-than-lemmatization-gt" class="headerlink" title="Why stemming is better than lemmatization&gt;?"></a>Why stemming is better than lemmatization&gt;?</h2><p>English has many morphological variants in its language, so it is<br>important to recognize these variants are related to the same root words.<br>Stemming helps on that. </p><p>Stemming is more robust than lemmatization, and can handle more<br>complicated cases.</p><h2 id="Why-stem-why-apply-to-both-query-and-document-processing"><a href="#Why-stem-why-apply-to-both-query-and-document-processing" class="headerlink" title="Why stem? why apply to both query and document processing?"></a>Why stem? why apply to both query and document processing?</h2><h1 id="2-Query-Processing"><a href="#2-Query-Processing" class="headerlink" title="2. Query Processing"></a>2. Query Processing</h1><p>执行和document一样的步骤</p><h2 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h2><p><img src="/2018/03/11/ir-review/index sparse.png" alt=""></p><p>统计每个term在每个doc的frequency，构建矩阵。 很稀疏。</p><p>解决办法：构建post list</p><p><img src="/2018/03/11/ir-review/post list.png" alt=""></p><p>但是里面没用位置信息，也没有哪个doc的term frequency</p><p>postlist会很大，不能存放在ram里，这样会降低查询效率，因此要使用编码去压缩字典</p><h2 id="Gamma-code"><a href="#Gamma-code" class="headerlink" title="Gamma code"></a>Gamma code</h2><p>length+offset</p><p>其中length由unary code组成(3 is 1110, 7 is 11111110)</p><p>Offset is binary, but first leading 1 is removed.</p><p>1110011(1110+011)</p><p>11111100101011110111</p><ul><li>1111110 010101-&gt; 1010101</li><li>1110 111 -&gt; 1111</li></ul><h1 id="Boolean-and-Vector-Space-Model"><a href="#Boolean-and-Vector-Space-Model" class="headerlink" title="Boolean and Vector Space Model"></a>Boolean and Vector Space Model</h1><h2 id="Boolean-Model"><a href="#Boolean-Model" class="headerlink" title="Boolean Model:"></a>Boolean Model:</h2><p>use and, or, not to search document.</p><h2 id="Vector-Space-Model"><a href="#Vector-Space-Model" class="headerlink" title="Vector Space Model"></a>Vector Space Model</h2><ul><li>replace relevance with ‘similarity’<ul><li>rank documents by their similarity with the query</li></ul></li><li>Treat the query as if it were a doucment</li></ul><p>Treat documents as vectors, term as axes of the space, vocabulary size = |V|, we have |V| dimensional vector space</p><h2 id="Tf-idf-why-we-need-inverse-document-frequency"><a href="#Tf-idf-why-we-need-inverse-document-frequency" class="headerlink" title="Tf-idf? why we need inverse document frequency?"></a>Tf-idf? why we need inverse document frequency?</h2><p>Tf-idf weighting increases with the numberof occurs within a document and the rarity of the term in the collection. Thedocument length is to help normalization, especially when calculating cos ofvectors, avoid the distortion caused by size of documents.</p><p>log frequency weight of a tem t is:</p><p><img src="/2018/03/11/ir-review/log frequency.png" alt=""></p><p>Idf:</p><script type="math/tex; mode=display">idf_t={log_{10}N}/{df_t}</script><p>tf-idf weight of a term:</p><p><img src="/2018/03/11/ir-review/tf-idf weight.png" alt=""></p><p><img src="/2018/03/11/ir-review/tf-idf.png" alt=""></p><h1 id="Language-Model"><a href="#Language-Model" class="headerlink" title="Language Model"></a>Language Model</h1><h2 id="differences-between-statistical-language-model-and-vector-space-model"><a href="#differences-between-statistical-language-model-and-vector-space-model" class="headerlink" title="differences between statistical language model and vector space model?"></a>differences between statistical language model and vector space model?</h2><p>In vector space model, we build the term-document matrix and calculate the similarity base on those terms which we preprocessed. And in the statistical language model we count the frequency to calculate the probability of each document to get the rank list of retrieval results. Usually those queries will let the document get higher score and return in the higher rank of retrieval list. So, base on those kinds of model we can still get the document what we need. </p><h2 id="Unigram-LM"><a href="#Unigram-LM" class="headerlink" title="Unigram LM"></a>Unigram LM</h2><p><img src="/2018/03/11/ir-review/unigram language model.png" alt=""></p><p><img src="/2018/03/11/ir-review/unigram eg.png" alt=""></p><h2 id="Query-Likelihodd-Language-Model"><a href="#Query-Likelihodd-Language-Model" class="headerlink" title="Query Likelihodd Language Model"></a>Query Likelihodd Language Model</h2><p><img src="/2018/03/11/ir-review/query likelihood.png" alt=""></p><p>长度会造成很大影响,因此提出了以下模型</p><p><img src="/2018/03/11/ir-review/mq.png" alt=""></p><p>但是概率很快就变成0了，因此我们需要smooth！</p><p><img src="/2018/03/11/ir-review/smooth.png" alt=""></p><h2 id="JM-smooth"><a href="#JM-smooth" class="headerlink" title="JM smooth"></a>JM smooth</h2><p><img src="/2018/03/11/ir-review/JM smooth.png" alt=""></p><p>加入参数$\lambda$, 通常$\lambda = 0.8$。</p><p>Mix the probability from document to general collection</p><h2 id="Dirichlet-prior-smoothing"><a href="#Dirichlet-prior-smoothing" class="headerlink" title="Dirichlet prior smoothing."></a>Dirichlet prior smoothing.</h2><p><img src="/2018/03/11/ir-review/dir smooth.png" alt=""></p><h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><h2 id="describe-what-is-topical-relevance-and-discuss-why-it-is-the-right-relevance-definition-for-Cranfield-evaluation-paradigm"><a href="#describe-what-is-topical-relevance-and-discuss-why-it-is-the-right-relevance-definition-for-Cranfield-evaluation-paradigm" class="headerlink" title="describe what is topical relevance, and discuss why it is the right relevance definition for Cranfield evaluation paradigm."></a>describe what is topical relevance, and discuss why it is the right relevance definition for Cranfield evaluation paradigm.</h2><p>Topical relevance is a type of relevance that is related to the content of the document and is objective, which is the result of the match between a query and the document, ignoring the role of users.</p><p>The topical relevance is the right relevance definition for Cranfield evaluation paradigm because when we use topic as our search standard,we can use different kind of model to calculate the score of each document orget the rank list of document collection. So, we can base on the topical relevance to get the retrieval results which user need.</p><h2 id="Precision-recall"><a href="#Precision-recall" class="headerlink" title="Precision, recall?"></a>Precision, recall?</h2><p><img src="/2018/03/11/ir-review/confusion matrix.png" alt=""></p><p>Precision = A / (A + B)</p><p>Recall = A / (A + C)</p><p><img src="/2018/03/11/ir-review/tradeoff.png" alt=""></p><p>Trade off</p><h2 id="describe-what-is-precision-then-discuss-why-we-need-to-consider-both-precision-and-recall-when-evaluating-information-retrieval-systems"><a href="#describe-what-is-precision-then-discuss-why-we-need-to-consider-both-precision-and-recall-when-evaluating-information-retrieval-systems" class="headerlink" title="describe what is precision, then discuss why we need to consider both precision and recall when evaluating information retrieval systems."></a>describe what is precision, then discuss why we need to consider both precision and recall when evaluating information retrieval systems.</h2><p>Precisionrepresent the percentage of the relevant document in the all retrieval results.So, the precision higher means that the retrieval accuracy is higher.</p><p>We need toconsider both precision and recall when evaluating information retrievalsystems, because it will base on different standard you set and get differentresults. Some system will more care about the recall because they need toretrieval all relevant document in their system. However, some system may justprefer to get the high percentage of the relevant documents in their results. So,we usually use the F-Measure to consider both precision and recall and use Betato trim the precision is more important or recall is more important.</p><p><img src="/2018/03/11/ir-review/f measure.png" alt=""></p><h2 id="R-precision"><a href="#R-precision" class="headerlink" title="R-precision"></a>R-precision</h2><p>R = |all relevant doc|</p><p><img src="/2018/03/11/ir-review/r precision.png" alt=""></p><h2 id="DCG"><a href="#DCG" class="headerlink" title="DCG"></a>DCG</h2><p><img src="/2018/03/11/ir-review/dcg.png" alt=""></p><p>当文档有相关程度reli的时候，我们就有了dcg去衡量，越相关的应该放在越前面。</p><h2 id="implicit-Relevance-Feedback-difference-with-pseudo-relevance-feedback"><a href="#implicit-Relevance-Feedback-difference-with-pseudo-relevance-feedback" class="headerlink" title="implicit Relevance Feedback, difference with pseudo relevance feedback?"></a>implicit Relevance Feedback, difference with pseudo relevance feedback?</h2><ul><li>Explicit relevance feedback<ul><li>users explicitly mark relevant and irrelevant documents in the search reuslts.</li></ul></li><li>Implicit relevance feedback<ul><li>system attempts to infer user intentions based on observable behavior</li></ul></li><li>Blind relevance feedback pseudo relevance feedback<ul><li>Avoid obtain user explicit or implicit feedback information.</li><li>use top returned N docs in the intial result </li><li>assume all of them are relevant</li></ul></li></ul><h2 id="pseudo-problem"><a href="#pseudo-problem" class="headerlink" title="pseudo problem"></a>pseudo problem</h2><p>When we do the relevance feedback we need user to provide their feedback or help us to define some answer for building a better query. But in pseudo relevance feedback, we don’t ask the user to provide the feedback. What we do is to see the top N of first retrieval documents as the relevance to the user’s query and use those documents to build an advanced query to search in the system.</p><h2 id="Rocchio"><a href="#Rocchio" class="headerlink" title="Rocchio"></a>Rocchio</h2><p><img src="/2018/03/11/ir-review/rocchio.png" alt=""></p><p>如何衡量ir system</p><h2 id="Known-item-search-evaluation-measure"><a href="#Known-item-search-evaluation-measure" class="headerlink" title="Known item search? evaluation measure?"></a>Known item search? evaluation measure?</h2><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Information Retrieval的复习笔记，感觉最近忙到爆炸，春假了在图书馆发霉。真的爆炸！！&lt;/p&gt;
&lt;h1 id=&quot;1-Text-Processing&quot;&gt;&lt;a href=&quot;#1-Text-Processing&quot; class=&quot;headerlink&quot; title=&quot;1. Text Processing&quot;&gt;&lt;/a&gt;1. Text Processing&lt;/h1&gt;&lt;h2 id=&quot;What-is-Bag-of-words-How-to-simplify-calculation&quot;&gt;&lt;a href=&quot;#What-is-Bag-of-words-How-to-simplify-calculation&quot; class=&quot;headerlink&quot; title=&quot;What is Bag of words? How to simplify calculation?&quot;&gt;&lt;/a&gt;What is Bag of words? How to simplify calculation?&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/03/11/ir-review/bag of words.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;Bag of words is a collection of words appear in document. It assmume the word is independent with each other. Also it failed to recognize semantic relationship among words, it would not tell you synonyms words, hyponym and hypernym, homonyms. But we can tokenize each word unit for indexing, stemming.&lt;/p&gt;
    
    </summary>
    
    
      <category term="Information Retrieval" scheme="https://hzjry123.github.io/tags/Information-Retrieval/"/>
    
  </entry>
  
  <entry>
    <title>SVM理解与推导 (二)</title>
    <link href="https://hzjry123.github.io/2018/03/05/SVM2/"/>
    <id>https://hzjry123.github.io/2018/03/05/SVM2/</id>
    <published>2018-03-05T17:00:39.000Z</published>
    <updated>2018-03-21T07:04:12.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SVM之松弛变量"><a href="#SVM之松弛变量" class="headerlink" title="SVM之松弛变量"></a>SVM之松弛变量</h1><p>上文我们说到了SVM的推导，也清楚了我们的目标就是求得使街宽margin最大的hyper plane。那么问题来了，如果数据里存在部分噪声使街宽很小，甚至线性不可分了，这又该怎么办，街宽小了模型缺少泛化能力，而线性不可分了我们必须去引进SVM的kernel了（在下一节会讲到）。</p><p><img src="/2018/03/05/SVM2/sv.png" alt=""></p><p>就例如下图被黑线描绘出的蓝点。原本我们的margin（彩色）还是十分美好的，但是加上这个噪音之后，新的margin就变成黑色虚线了，模型的泛化能力一下就差了许多，部分点就会出现分错的情况。</p><a id="more"></a><p><img src="/2018/03/05/SVM2/outlier.png" alt=""></p><p>原来的约束条件：</p><script type="math/tex; mode=display">y(w^TX+b)\geq1</script><p>看我们原来的约束条件，如何修改能使这些噪声点不产生如此之大的影响呢？显然我们应该在不等式的右边把这个1变小，且针对每个样本点，右边的值应该是不同的，针对噪声，右边显然应该更小甚至为负数，针对support vector，显然越接近1越好。</p><p>因此：</p><script type="math/tex; mode=display">y(w^TX+b)\geq1 - \xi_i,  \ \ \ \ \ \ \ i = 1,...,n， \xi_i>0</script><p>其中$\xi_i$就是我们的松弛变量了。那么问题来了，现在的噪音还是我们的support vector吗，回忆之前求街宽的过程，我们就是用支持向量来求的。那么现在我们只需</p><script type="math/tex; mode=display">Width =(X^+-X^-)\frac{w}{||w||} \\=\frac{X^+w}{||w||}-\frac{X^-w}{||w||}\\因为wx=\frac{1-\xi}{y}-b\\Width=\frac{1-\xi-b}{||w||}-\frac{-1+\xi-b}{||w||}=\frac{2-\xi}{||w||}</script><p>（上述步骤好像在别的地方没有看见过，不知道是不是我搞错了= =）</p><p>同理我们要街宽最大，即分母$w$最小，分子$2-\xi$最大，即我们希望$\xi$很小。因此我们得到新的优化问题和约束条件：</p><script type="math/tex; mode=display">min\frac{||w||^2}{2}+C\sum^n_{i=1}\xi_i\\s.t. \xi_i>0, \\y(w^TX+b)\geq1 - \xi_i</script><p>其中C是一个参数，用于控制$\xi$的权重和w的平衡，其实就和正则项很像，不能过大不然这个超平面就根本没用了。</p><p>根据拉格朗日函数：<br><img src="/2018/03/05/SVM2/lagrange.png" alt=""></p><p>同样的我们可以得到拉格朗日函数：</p><script type="math/tex; mode=display">Lmin=\frac{||w||^2}{2}+C\sum^n_{i=1}\xi_i-\sum \lambda _i[y_i(wx_i+b)-1+\xi_i]-\sum^n_{i=1}r_i\xi_i</script><p>同样求偏导，这次要加一个多$\xi_i$求偏导</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w}=w-\sum \lambda _i y_i x_i = 0\\=> w = \sum  \lambda _i y_i x_i \\\frac{\partial L}{\partial b}=\sum \lambda _i y_i=0\\ \frac{\partial L}{\partial \xi_i}= 0=> C-\lambda_i-r_i=0</script><p>我们可知$r_i\geq0,\lambda_i&lt;C$多了一个约束条件</p><p>带回原公式（$\xi$可以被消去，太晚了我就先不打公式了溜了有机会再说吧）：</p><script type="math/tex; mode=display">Lmin = \sum\lambda_i-\frac{1}{2} \sum^n _{i=1} \sum^n _{j=1} \lambda _i  \lambda _j y_i   y_j  x_i x_j\\ s.t. 0\leq\lambda_i\leq C \\ \sum^n_{i=1}\lambda_i y_i = 0</script><p><img src="/2018/03/05/SVM2/conclusion.png" alt=""></p><p>哇发现和之前简直一模一样，就是多了个C而已。</p><p>引用july大佬的一段总结：</p><blockquote><p>行文至此，可以做个小结，不准确的说，SVM它本质上即是一个分类方法，用$w^T+b$定义分类函数，于是求$w、b$，为寻最大间隔，引出$1/2||w||^2$，继而引入拉格朗日因子，化为对拉格朗日乘子$\lambda$的求解（求解过程中会涉及到一系列最优化或凸二次规划等问题），如此，求$w.b$与求$\lambda$等价，而$\lambda$的求解可以用一种快速学习算法SMO，至于核函数，是为处理非线性情况，若直接映射到高维计算恐维度爆炸，故在低维计算，等效高维表现。</p></blockquote><p>TODO: 核函数</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SVM之松弛变量&quot;&gt;&lt;a href=&quot;#SVM之松弛变量&quot; class=&quot;headerlink&quot; title=&quot;SVM之松弛变量&quot;&gt;&lt;/a&gt;SVM之松弛变量&lt;/h1&gt;&lt;p&gt;上文我们说到了SVM的推导，也清楚了我们的目标就是求得使街宽margin最大的hyper plane。那么问题来了，如果数据里存在部分噪声使街宽很小，甚至线性不可分了，这又该怎么办，街宽小了模型缺少泛化能力，而线性不可分了我们必须去引进SVM的kernel了（在下一节会讲到）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/05/SVM2/sv.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;就例如下图被黑线描绘出的蓝点。原本我们的margin（彩色）还是十分美好的，但是加上这个噪音之后，新的margin就变成黑色虚线了，模型的泛化能力一下就差了许多，部分点就会出现分错的情况。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>SVM理解与推导 (一)</title>
    <link href="https://hzjry123.github.io/2018/03/05/SVM/"/>
    <id>https://hzjry123.github.io/2018/03/05/SVM/</id>
    <published>2018-03-05T09:57:27.000Z</published>
    <updated>2018-03-21T06:46:17.311Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍什么是SVM</p><h1 id="SVM是什么？"><a href="#SVM是什么？" class="headerlink" title="SVM是什么？"></a>SVM是什么？</h1><p>SVM: support vector machine,俗称支持向量机。是一种二分类模型，其模型定义为特征空间上的间隔最大的线性分类器，策略就是间隔最大化，最终转化为一个凸二次规划问题的求解。感觉已经晕了，下图给出一些intuition的部分:</p><p><img src="/2018/03/05/SVM/intution1.png" alt="ntution"></p><p>假设我们有一堆正负样本如图，我们想找一条线（一个超平面）去把这些点分开来。这条线当然是无穷条的，在图中我以H2 和 H3为例，H2和H3看起来都把正负样本分开了，但是我们的目标不是在训练集上取得好成绩吧，我们的目标还包括测试集（unseen data）。</p><p><img src="/2018/03/05/SVM/intuition.png" alt=""></p><p>这时候我们给出了测试集（就是我新加上去的点），我们发现H2这条线完全分错了。而H3则分类的不错，粗略得来讲，H3距离正负样本的距离都很远，因此他的泛化能力很强。</p><p>至此我们明确了我们的任务，就是找到H3。那么很自然的，我们就产生了两个问题：</p><ol><li>如果这样的超平面确实存在，如何寻找？</li><li>如果这样的超平面不存在，那么如何找到一个尽可能分开正负样本的超平面？</li></ol><a id="more"></a><h1 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h1><script type="math/tex; mode=display">方法=模型+策略+算法</script><p>回顾之前的方法三要素，我们知道我们的方法要包括模型，策略，算法。即</p><ol><li>假设函数$h(\theta)$</li><li>损失函数$J(\theta)$</li><li>求解方法梯度下降。</li></ol><p>那么我们如何在SVM里套用这样的公式呢？我参考了许多网上的推导过程，在SVM里损失函数反而提到的不多，可能也和他的推导过程有关吧。因此在本文，$h(\theta)$和$J(\theta)$将在最后给出。下文将逐步给出SVM的推导过程。</p><h1 id="超平面H3的寻找"><a href="#超平面H3的寻找" class="headerlink" title="超平面H3的寻找"></a>超平面H3的寻找</h1><h2 id="超平面的定义"><a href="#超平面的定义" class="headerlink" title="超平面的定义"></a>超平面的定义</h2><p>首先我们定义超平面为</p><script type="math/tex; mode=display">H=w^TX+b</script><p>$w,b$是超平面的参数，$X$是样本点。</p><h2 id="对超平面的关键假设"><a href="#对超平面的关键假设" class="headerlink" title="对超平面的关键假设"></a>对超平面的关键假设</h2><p>在SVM中，我们假设或者可以理解为经过缩放：</p><script type="math/tex; mode=display">w^TX^++b \geq1</script><script type="math/tex; mode=display">w^TX^-+b \leq-1</script><p>*叫做缩放可能更有利于理解。</p><p>即一个正样本代入公式，我们希望得出的值$\geq1$，一个负样本代入公式，我们希望得出的值$\leq-1$。而样本代入公式得到的值叫做间隔，该假设（或者叫缩放）称为最大间隔假设。这是SVM里一个很重要的前提，在求解上会提供很大的方便。</p><h2 id="支持向量"><a href="#支持向量" class="headerlink" title="支持向量"></a>支持向量</h2><p>那么现在我们可以粗略的了解到，在最大间隔假设下，对于训练正样本（注意是训练样本），代入平面公式最小得到的是1，对于训练负样本（注意是训练样本），代入平面公式最大得到的是-1。</p><p>因此我们称$w^TX^++b =1$, $w^TX^-+b =-1$的点为Support Vector（支持向量），支持向量就恰好落在这个分界线上，（到现在为止）在训练集中，两边的支持向量中间的<strong>街道</strong>是没有任何样本点的。</p><p><img src="/2018/03/05/SVM/sample.png" alt=""></p><p>对于支持向量，有如下性质</p><script type="math/tex; mode=display">y^+(w^TX^++b)=1 * 1 =1</script><script type="math/tex; mode=display">y^-(w^TX^-+b)=-1 *- 1 =1</script><p>因此写成一个公式</p><script type="math/tex; mode=display">y(w^TX+b)=1</script><p>这就是SVM第一个很重要的点。</p><h2 id="街道宽度—几何间隔"><a href="#街道宽度—几何间隔" class="headerlink" title="街道宽度—几何间隔"></a>街道宽度—几何间隔</h2><p>在之前我们大概了解到，如果中间街道的宽度越大，svm的泛化能力就越好！</p><p>那么问题就转移到怎么找$w,b$使得街道的宽度最大了。那么我们现在首先得得到街道的宽度，在SVM里，我们称之为<strong>几何间隔</strong>。</p><p><img src="/2018/03/05/SVM/street.png" alt=""></p><p>假设我们有两个个样本点$X^+,X^-$，那么可知黄色的向量$X^+-X^-$落在$wx+b=0$的法向量$w$（此处可以百度回忆一下法向量）上的长度就是街宽！因此</p><script type="math/tex; mode=display">Width =(X^+-X^-)\frac{w}{||w||} \\=\frac{X^+w}{||w||}-\frac{X^-w}{||w||}\\因为wx=\frac{1}{y}-b\\Width=\frac{1-b}{||w||}-\frac{-1-b}{||w||}=\frac{2}{||w||}</script><p>(此处$X^+,X^-,w$都是向量)。</p><p>至此我们得到了几何间隔了，根据我们之前的intuition，我们希望几何间隔最大。</p><p>至此，我们得到</p><script type="math/tex; mode=display">max\frac{2}{||w||} \quad s.t. \quad y(xw+b) = 1\\同时max\frac{2}{||w||}<=>min||w||<=>min\frac{||w||^2}{2}</script><p>为什么要将$max\frac{2}{||w||} $变成$min\frac{||w||^2}{2}$呢？因为方便求导嘛。现在我们的任务就是求解了。</p><h2 id="拉格朗日"><a href="#拉格朗日" class="headerlink" title="拉格朗日"></a>拉格朗日</h2><p>现在我们有一个约束条件，$y(xw+b) = 1$，一个优化目标$min\frac{||w||^2}{2}$，使用拉格朗日求解，定义如下：</p><p><img src="/2018/03/05/SVM/lagrange.png" alt=""></p><p>根据拉格朗日乘子法，我们可以转换我们的问题为：</p><script type="math/tex; mode=display">L=\frac{||w||^2}{2}-\sum \lambda _i[y_i(wx_i+b)-1]</script><p>对w和b分别求偏导：</p><script type="math/tex; mode=display">\frac{\partial L}{\partial w}=w-\sum \lambda _i y_i x_i = 0\\=> w = \sum  \lambda _i y_i x_i \\\frac{\partial L}{\partial b}=\sum \lambda _i y_i=0</script><p>将$\sum \lambda _i y_i=0$, $ w = \sum  \lambda _i y_i x_i \$带回$L$，</p><script type="math/tex; mode=display">L= w =\frac{1}{2} \sum  \lambda _i y_i x_i  \sum  \lambda _j y_j x_j\\ - \sum  \lambda _i y_i x_i  \sum  \lambda _j y_j x_j \\ - \sum  \lambda _i y_i b +\sum\lambda_i \\L = \sum\lambda_i-\frac{1}{2} \sum^n _{i=1} \sum^n _{j=1} \lambda _i  \lambda _j y_i   y_j  x_i x_j\\s.t.  \sum^n_{i=1}\lambda_i y_i = 0</script><p>我们所要关注的就是如何求解$\lambda​$ 了。在这里推荐大家看<a href="http://blog.csdn.net/v_july_v/article/details/7624837里的3.5" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7624837里的3.5</a> SMO求解拉格朗日乘子。</p><p>TODO:松弛变量、 核函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍什么是SVM&lt;/p&gt;
&lt;h1 id=&quot;SVM是什么？&quot;&gt;&lt;a href=&quot;#SVM是什么？&quot; class=&quot;headerlink&quot; title=&quot;SVM是什么？&quot;&gt;&lt;/a&gt;SVM是什么？&lt;/h1&gt;&lt;p&gt;SVM: support vector machine,俗称支持向量机。是一种二分类模型，其模型定义为特征空间上的间隔最大的线性分类器，策略就是间隔最大化，最终转化为一个凸二次规划问题的求解。感觉已经晕了，下图给出一些intuition的部分:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/05/SVM/intution1.png&quot; alt=&quot;ntution&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一堆正负样本如图，我们想找一条线（一个超平面）去把这些点分开来。这条线当然是无穷条的，在图中我以H2 和 H3为例，H2和H3看起来都把正负样本分开了，但是我们的目标不是在训练集上取得好成绩吧，我们的目标还包括测试集（unseen data）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/03/05/SVM/intuition.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;这时候我们给出了测试集（就是我新加上去的点），我们发现H2这条线完全分错了。而H3则分类的不错，粗略得来讲，H3距离正负样本的距离都很远，因此他的泛化能力很强。&lt;/p&gt;
&lt;p&gt;至此我们明确了我们的任务，就是找到H3。那么很自然的，我们就产生了两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果这样的超平面确实存在，如何寻找？&lt;/li&gt;
&lt;li&gt;如果这样的超平面不存在，那么如何找到一个尽可能分开正负样本的超平面？&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>python filter</title>
    <link href="https://hzjry123.github.io/2018/03/02/python-filter/"/>
    <id>https://hzjry123.github.io/2018/03/02/python-filter/</id>
    <published>2018-03-02T06:16:48.000Z</published>
    <updated>2018-03-02T19:16:48.070Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>K-Means</title>
    <link href="https://hzjry123.github.io/2018/03/01/k-means/"/>
    <id>https://hzjry123.github.io/2018/03/01/k-means/</id>
    <published>2018-03-02T04:14:10.000Z</published>
    <updated>2018-03-09T17:14:40.186Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>logistic regression</title>
    <link href="https://hzjry123.github.io/2018/03/01/logistic-regression/"/>
    <id>https://hzjry123.github.io/2018/03/01/logistic-regression/</id>
    <published>2018-03-02T03:57:53.000Z</published>
    <updated>2018-03-03T07:55:57.636Z</updated>
    
    <content type="html"><![CDATA[<h1 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h1><h2 id="构造过程"><a href="#构造过程" class="headerlink" title="构造过程"></a>构造过程</h2><script type="math/tex; mode=display">方法=模型+策略+算法</script><p>回顾之前的方法三要素，我们知道我们的方法要包括模型，策略，算法。即</p><ol><li>假设函数$h(\theta)$</li><li>损失函数$J(\theta)$</li><li>求解方法梯度下降。</li></ol><h2 id="假设函数-h-theta"><a href="#假设函数-h-theta" class="headerlink" title="假设函数$h(\theta)$"></a>假设函数$h(\theta)$</h2><h3 id="简单介绍："><a href="#简单介绍：" class="headerlink" title="简单介绍："></a>简单介绍：</h3><p>当我们在针对二分类问题的时候，预测邮件是否为垃圾邮件，肿瘤是否为良性等等，由于我们的预测结果只有0，1，因此这种分类问题我们无法使用线性回归再去预测。</p><p>原因：</p><ol><li>线性回归要求数据符合正态分布，逻辑回归要求数据符合0，1分布。</li><li>线性回归要求$x,y$符合线性关系，逻辑回归则没有要求。</li><li>线性回归预测的是分析的是$x,y$的关系，而逻辑回归是分析$y$取某个值的概率与自变量的关系。</li><li>线性回归要求$y$是连续变量，逻辑回归要求$y$是离散变量。</li></ol><a id="more"></a><h3 id="h-theta"><a href="#h-theta" class="headerlink" title="$h(\theta)$"></a>$h(\theta)$</h3><p>逻辑回归的模型是sigmoid function(logistic function)</p><script type="math/tex; mode=display">h_\theta (x) = g(\theta ^T x)=P(y=1|x,\theta)</script><script type="math/tex; mode=display">g(z) =\frac{1}{1+e^{-z}}</script><p><img src="/2018/03/01/logistic-regression/sigmoid.png" alt=""></p><p>我们假设大于0.5时预测值为1，小于0.5时预测值为0。</p><script type="math/tex; mode=display">P(y=1|x,\theta) =h_\theta (x)</script><script type="math/tex; mode=display">P(y=0|x,\theta)=1-h_\theta (x)</script><h2 id="损失函数-J-theta"><a href="#损失函数-J-theta" class="headerlink" title="损失函数$J(\theta)$"></a>损失函数$J(\theta)$</h2><p>在上一步中我们得到了如下的公式：</p><script type="math/tex; mode=display">h_\theta (x)=\frac{1}{1+e^{-\theta^Tx}}</script><p>那么我们要怎么去得到$\theta$呢？</p><p>在线性回归中我们得到了一个损失函数，即平方差损失函数</p><script type="math/tex; mode=display">J(\theta) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2</script><p>但是这种损失函数应用在逻辑回归里会得到non-convex的结果。</p><p><img src="/2018/03/01/logistic-regression/convex.png" alt=""></p><p>有多个local optimal, 这显然不合理啊。我们期待得到的是一个convex的函数，有global minimum。因此这个不得行，逻辑回归选择了对数损失函数</p><script type="math/tex; mode=display">\begin{align*}& J(\theta) = \dfrac{1}{m} \sum_{i=1}^m \mathrm{Cost}(h_\theta(x^{(i)}),y^{(i)}) \newline & \mathrm{Cost}(h_\theta(x),y) = -\log(h_\theta(x)) \; & \text{if y = 1} \newline & \mathrm{Cost}(h_\theta(x),y) = -\log(1-h_\theta(x)) \; & \text{if y = 0}\end{align*}</script><p>画出图像如下:</p><p><img src="/2018/03/01/logistic-regression/y=0.png" alt=""></p><p>intuition：在y=1时，$h(\theta)$越接近1，损失值越小，当$h(\theta)$接近0时，损失值接近无穷。</p><p>在y=0时，$h(\theta)$越接近0，损失值越大，当$h(\theta)$接近1时，损失值接近无穷。</p><script type="math/tex; mode=display">\begin{align*}& \mathrm{Cost}(h_\theta(x),y) = 0 \text{ if } h_\theta(x) = y \newline & \mathrm{Cost}(h_\theta(x),y) \rightarrow \infty \text{ if } y = 0 \; \mathrm{and} \; h_\theta(x) \rightarrow 1 \newline & \mathrm{Cost}(h_\theta(x),y) \rightarrow \infty \text{ if } y = 1 \; \mathrm{and} \; h_\theta(x) \rightarrow 0 \newline \end{align*}</script><script type="math/tex; mode=display">J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]</script><p>从结果看是很好，很能符合逻辑回归的特点那我们是怎么知道要用这个形式的损失函数的呢？</p><h3 id="J-theta-推导过程"><a href="#J-theta-推导过程" class="headerlink" title="$J(\theta)$推导过程"></a>$J(\theta)$推导过程</h3><script type="math/tex; mode=display">P(y=1|x,\theta) =h_\theta (x) \\P(y=0|x,\theta)=1-h_\theta (x)</script><p>对公式(9)来说，我们可以写成</p><script type="math/tex; mode=display">P(y|x;\theta)=(h_\theta(x))^y(1-h_\theta(x))^{1-y}</script><p>intuition：y=1时，预测函数取1的概率，y=0时，预测函数取0的概率。当然这个值我们希望越大越好。</p><p>因此取似然函数为，做最大似然估计：</p><script type="math/tex; mode=display">L(\theta)=\prod ^m_{i=1}(h_\theta(x^i))^{y^{i}}(1-h_\theta(x^i))^{1-y^{i}}</script><p>难以求解，取对数</p><script type="math/tex; mode=display">l(\theta)=logL(\theta)=\sum ^m _{i=1}(y^i\ logh_\theta (x^i) + (1-y^i)log(1-h_\theta(x^i))</script><p>对比公式(8)，我们发现缺少了1/m，这个好理解，平滑损失值。但是出现了一个负号。这个负号在线性回归的损失函数里是没有的：</p><script type="math/tex; mode=display">J(\theta) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2</script><p>其实也可以这么用，不用取负号，使用梯度向上法求解。但是Andrew Ng是加了负号。</p><p>个人理解：因为在最大似然函数里，我们求的是使公式值最大的$\theta$的值，但是在损失函数里，我们求得是损失最小值，为了方便我们理解损失函数以及梯度下降，Andrew取了负号。但是本质已经和线性回归不一样了。</p><p>于是可得到</p><script type="math/tex; mode=display">\begin{align*}& J(\theta) = \dfrac{1}{m} \sum_{i=1}^m \mathrm{Cost}(h_\theta(x^{(i)}),y^{(i)}) \newline & \mathrm{Cost}(h_\theta(x),y) = -\log(h_\theta(x)) \; & \text{if y = 1} \newline & \mathrm{Cost}(h_\theta(x),y) = -\log(1-h_\theta(x)) \; & \text{if y = 0}\end{align*}</script><script type="math/tex; mode=display">J(\theta) = - \frac{1}{m} \displaystyle \sum_{i=1}^m [y^{(i)}\log (h_\theta (x^{(i)})) + (1 - y^{(i)})\log (1 - h_\theta(x^{(i)}))]</script><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><script type="math/tex; mode=display">\theta:=\theta-\alpha \frac{d}{d\theta} J(\theta)</script><h3 id="求偏导部分-alpha-frac-d-d-theta-J-theta-："><a href="#求偏导部分-alpha-frac-d-d-theta-J-theta-：" class="headerlink" title="求偏导部分$\alpha \frac{d}{d\theta} J(\theta)$："></a>求偏导部分$\alpha \frac{d}{d\theta} J(\theta)$：</h3><p><img src="/2018/03/01/logistic-regression/tuidao.png" alt=""></p><p>因此参数更新：</p><script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{1}{m} \sum_{i=1}^m{ \left(\frac{1}{1 + e^{-\theta^T x^{(i)}}} - y^{(i)}\right) x_j^{(i)}}(simultaneously \ update \ for \ all \ j)</script><p>对比线性回归，两个方程是一样的，差别在$(h_\theta(x^{(i)})$.</p><script type="math/tex; mode=display">\theta_j := \theta_j - \alpha \frac{1}{m} \sum_{i=1}^m{ (h_\theta(x^{(i)}) - y^{(i)}) x^{(i)}_j} (simultaneously \ update \ for \ all \ j).</script><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sigmoid</span><span class="params">(inX)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0</span>/(<span class="number">1</span>+exp(inX))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradDesc</span><span class="params">(dataMatIn, classLabels)</span>:</span></span><br><span class="line">    dataMatrix = mat(dataMatIn)</span><br><span class="line">    labelMat = mat(classLabels).transpose()</span><br><span class="line">    m,n = shape(dataMatrix)</span><br><span class="line">    alpha = <span class="number">0.001</span></span><br><span class="line">    maxCycles = <span class="number">500</span></span><br><span class="line">    thetas = ones((n,<span class="number">1</span>))</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> range(maxCycles):</span><br><span class="line">        h = sigmoid(dataMatrix * thetas)</span><br><span class="line">        error = h - labels</span><br><span class="line">        thetas = thetas - alpha * dataMatrix.tranpose()*error</span><br><span class="line">    <span class="keyword">return</span> thetas</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;逻辑回归&quot;&gt;&lt;a href=&quot;#逻辑回归&quot; class=&quot;headerlink&quot; title=&quot;逻辑回归&quot;&gt;&lt;/a&gt;逻辑回归&lt;/h1&gt;&lt;h2 id=&quot;构造过程&quot;&gt;&lt;a href=&quot;#构造过程&quot; class=&quot;headerlink&quot; title=&quot;构造过程&quot;&gt;&lt;/a&gt;构造过程&lt;/h2&gt;&lt;script type=&quot;math/tex; mode=display&quot;&gt;
方法=模型+策略+算法&lt;/script&gt;&lt;p&gt;回顾之前的方法三要素，我们知道我们的方法要包括模型，策略，算法。即&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假设函数$h(\theta)$&lt;/li&gt;
&lt;li&gt;损失函数$J(\theta)$&lt;/li&gt;
&lt;li&gt;求解方法梯度下降。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;假设函数-h-theta&quot;&gt;&lt;a href=&quot;#假设函数-h-theta&quot; class=&quot;headerlink&quot; title=&quot;假设函数$h(\theta)$&quot;&gt;&lt;/a&gt;假设函数$h(\theta)$&lt;/h2&gt;&lt;h3 id=&quot;简单介绍：&quot;&gt;&lt;a href=&quot;#简单介绍：&quot; class=&quot;headerlink&quot; title=&quot;简单介绍：&quot;&gt;&lt;/a&gt;简单介绍：&lt;/h3&gt;&lt;p&gt;当我们在针对二分类问题的时候，预测邮件是否为垃圾邮件，肿瘤是否为良性等等，由于我们的预测结果只有0，1，因此这种分类问题我们无法使用线性回归再去预测。&lt;/p&gt;
&lt;p&gt;原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线性回归要求数据符合正态分布，逻辑回归要求数据符合0，1分布。&lt;/li&gt;
&lt;li&gt;线性回归要求$x,y$符合线性关系，逻辑回归则没有要求。&lt;/li&gt;
&lt;li&gt;线性回归预测的是分析的是$x,y$的关系，而逻辑回归是分析$y$取某个值的概率与自变量的关系。&lt;/li&gt;
&lt;li&gt;线性回归要求$y$是连续变量，逻辑回归要求$y$是离散变量。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>正则化</title>
    <link href="https://hzjry123.github.io/2018/02/23/regularize-1/"/>
    <id>https://hzjry123.github.io/2018/02/23/regularize-1/</id>
    <published>2018-02-24T02:29:43.000Z</published>
    <updated>2018-03-13T19:08:05.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则化定义"><a href="#正则化定义" class="headerlink" title="正则化定义"></a>正则化定义</h2><p>在数据量很少，特征很多的时候，模型往往会表现的过于复杂。bias(训练误差)会降低，但是variance(测试误差)会升高，会产生过拟合的情况。</p><h3 id="过拟合为什么不好"><a href="#过拟合为什么不好" class="headerlink" title="过拟合为什么不好"></a>过拟合为什么不好</h3><p>比如我们想预测匹兹堡市的年收入情况，但是我们只采访了匹兹堡大学周围的人，没有采访别的人，我们在用这部分数据预测的时候，预测匹兹堡大学周围的生日当然是可以的，但是想预测整个匹兹堡的收入呢？自然不行。数据并没有代表性，或者说数据的有些维度在测试集是可以帮助达到global optimal，但是在unseen dataset中并没有卵用，导致了模型没有泛化能力。</p><p><img src="/2018/02/23/regularize-1/overfitting.png" alt=""></p><a id="more"></a><p>P为特征数，n为样本数。样本数太少，可能造成过拟合</p><p>因此我们要在bias和variance之间找一个tradeoff。</p><p><img src="/2018/02/23/regularize-1/tradeoff.png" alt=""></p><p>降低模型复杂度有两种方法：</p><ul><li><p>减少特征的数量：</p><blockquote><p>具体而言，我们可以人工检查每一项变量，并以此来确定哪些变量更为重要，然后，保留那些更为重要的特征变量。至于，哪些变量应该舍弃，我们以后在讨论，这会涉及到模型选择算法，这种算法是可以自动选择采用哪些特征变量，自动舍弃不需要的变量。这类做法非常有效，但是其缺点是当你舍弃一部分特征变量时，你也舍弃了问题中的一些信息。例如，也许所有的特征变量对于预测房价都是有用的，我们实际上并不想舍弃一些信息或者说舍弃这些特征变量。</p></blockquote></li><li><p>降低特征的权重:</p><blockquote><p>当我们有很多特征变量时，其中每一个变量都能对预测产生一点影响。正如我们在房价预测的例子中看到的那样，我们可以有很多特征变量，其中每一个变量都是有用的，因此我们不希望把它们删掉，这就导致了正则化概念的发生。</p></blockquote></li></ul><p>正则化一般具有如下形式：</p><script type="math/tex; mode=display">min\frac{1}{N}\sum_{i}^{N}{L(y_1,f(x_1)) } + \lambda J(f)</script><p>第一项是经验风险$R<em>{emp}$，第二项是正则化项$r(d)$，$\lambda \geq 0$为调整两者之间关系的系数. $R</em>{emp}+r(d)$结构风险，正则化就是结构风险最小化的过程。</p><blockquote><p> 对于第一项Loss函数，如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是exp-Loss，那就是牛逼的 Boosting了；如果是log-Loss，那就是Logistic Regression了；</p></blockquote><h2 id="L1vsL2"><a href="#L1vsL2" class="headerlink" title="L1vsL2"></a>L1vsL2</h2><p>在正则化项中我们引入了0-2范数：</p><ul><li><p>0范数，向量中非零元素的个数。</p></li><li><p>1范数，为绝对值之和（Lasso regularization）</p><script type="math/tex; mode=display">L1=min\frac{1}{N}\sum_{i}^{N}{L(y_1,f(x_1)) } + {\lambda }  \left| \left| W \right|  \right| _{1}</script></li><li><p>2范数，就是通常意义上的模（Ridge Regression），向量各元素的平方和然后求平方根。</p></li></ul><script type="math/tex; mode=display">L2=min\frac{1}{N}\sum_{i}^{N}{L(y_1,f(x_1)) } + {\lambda }  \left| \left| W \right|  \right| _{2} ^{2}</script><h3 id="L1-L2特点"><a href="#L1-L2特点" class="headerlink" title="L1,L2特点"></a>L1,L2特点</h3><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/2018/02/23/regularize-1/L1vsL2.png" alt=""></h2><p>L1范数会将所有特征的参数shrinka接近0，会选择出关键的特征，便于解释模型，但在梯度下降求偏导中会有点麻烦（绝对值）。</p><p>L2范数会将部分参数接近0，从学习理论的角度可以防止过拟合，提高模型的泛化能力，求偏导简单（似乎因此更popular）。</p><h3 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h3><p><img src="/2018/02/23/regularize-1/Gradient.png" alt=""></p><p>$l_1$和$l_2$在梯度下降中如图所示，$l_1$的下降速度在靠近0的时候非常快，所以会很快降到0。</p><h3 id="★为什么L1、L2有如此区别以及L1、L2是怎么运作的？"><a href="#★为什么L1、L2有如此区别以及L1、L2是怎么运作的？" class="headerlink" title="★为什么L1、L2有如此区别以及L1、L2是怎么运作的？"></a>★为什么L1、L2有如此区别以及L1、L2是怎么运作的？</h3><p><img src="/2018/02/23/regularize-1/ball.png" alt=""></p><h3 id="图形解释："><a href="#图形解释：" class="headerlink" title="图形解释："></a>图形解释：</h3><script type="math/tex; mode=display">min\frac{1}{N}\sum_{i}^{N}{L(y_1,f(x_1)) }</script><p>为方便表示我们只考虑二维的平面，即$w_1,w_2$两个特征，在$w_1,w_2$平面内画出目标函数的等高线，这个等高线我们知道就是目标函数的碗投影在二维图中的表示。</p><script type="math/tex; mode=display">\lambda J(f)</script><p>$l_2$正则项则成为平面上半径为C（这个C在sklearn的logistics中可以定义）的一个圆。</p><p>$l_1$正则项则成为平面上对角线一半为C的一个正方形。（这里省去$\lambda$而改用C，$\lambda=\frac{1}{C}$）</p><h3 id="求解的intuition以及为什么可以防止过拟合1"><a href="#求解的intuition以及为什么可以防止过拟合1" class="headerlink" title="求解的intuition以及为什么可以防止过拟合1"></a>求解的intuition以及为什么可以防止过拟合1</h3><p>我们知道碗（等高线）的optimal在最中心的地方，但是我们现在不要那个地方最拟合的解，我们要不那么完美的解，因此我们加入了正则项，把正则项的投影到图中，正则项最小的地方自然在原点处。</p><p><strong>我们所希望的$w_1,w_2$ s.t. 正则项也小，损失函数也小，因此我们就在这里有一个trade off</strong>：</p><ul><li>C越大($\lambda$越小)，交点越靠近碗的optimal，惩罚程度越小，模型可能还是过拟合。</li><li>C越小($\lambda$越大)，交点越靠近原点，惩罚程度越大，但是模型表现可能欠拟合。</li></ul><p>可以看到$l_1$和$l_2$的不同之处在于$l_1$和坐标轴和坐标轴相交的地方有角，大部分的时候目标函数会和$l_1$在角处相交，而角处是有稀疏性的。</p><p>$l_2$因为没有角，所以相交在有稀疏性的地方概率很小。这样就直观的解释了为什么$l_1$可以产生稀疏性，$l_2$不可以产生稀疏性。</p><h2 id="正则化为什么可以防止过拟合2"><a href="#正则化为什么可以防止过拟合2" class="headerlink" title="正则化为什么可以防止过拟合2"></a>正则化为什么可以防止过拟合2</h2><p>为了防止过拟合，我们要让经验风险最小化，正则化项也最小化，即让两者之和最小化</p><p>那么我们如何说明加入了这个正则项后，相较于$\hat{\bf{\beta}}$来说，$\widetilde{\bf{\beta}}$确实避免了过拟合呢？</p><p>因为从数学上可以证明，$\Vert \widetilde{\bf{\beta}} \Vert &lt; \Vert \hat{\bf{\beta}} \Vert $，注意这里的小于是严格的小于。这个性质本身告诉了我们这样一个及其重要的本质：</p><p>加入正则项后，估计出的（向量）参数的<strong>长度变短</strong>了（数学上称为shrinkage）。</p><p>换句话说，<strong>长度变短</strong>了就意味着，向量$\widetilde{\bf{\beta}}$中的某些分量在总体程度上比$\hat{\bf{\beta}}$的分量<strong>变小</strong>了。极端来说，向量$\widetilde{\bf{\beta}}$中的某些分量<strong>可能</strong>（因为也可能是因为每个分量都变小一点点最后造成整体长度变小）被压缩到了0。</p><p>虽然这里其实还没有完整说明我们实现了避免过拟合，但至少从某种程度上说，加入正则项和的参数估计是符合我们之前的预定目标的，即用尽量少的变量去拟合数据。</p><p>在知乎上看到的解答：</p><blockquote><p>向你的模型加入某些规则，加入先验，缩小解空间，减小求出错误解的可能性。你要把你的知识数学化告诉这个模型，对代价函数来说，就是加入对模型“长相”的惩罚. 损失一部分，让模型无法完美的拟合</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p> 因此，一句话总结就是：L1会趋向于产生少量的特征，而其他的特征都是0，而L2会选择更多的特征，这些特征都会接近于0。Lasso在特征选择时候非常有用，而Ridge就只是一种规则化而已。</p></blockquote><p>ref: <a href="http://blog.csdn.net/zouxy09/article/details/24971995" target="_blank" rel="noopener">http://blog.csdn.net/zouxy09/article/details/24971995</a></p><p>Coursea: Machine Learning</p><p>&amp;Phd罗.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;正则化定义&quot;&gt;&lt;a href=&quot;#正则化定义&quot; class=&quot;headerlink&quot; title=&quot;正则化定义&quot;&gt;&lt;/a&gt;正则化定义&lt;/h2&gt;&lt;p&gt;在数据量很少，特征很多的时候，模型往往会表现的过于复杂。bias(训练误差)会降低，但是variance(测试误差)会升高，会产生过拟合的情况。&lt;/p&gt;
&lt;h3 id=&quot;过拟合为什么不好&quot;&gt;&lt;a href=&quot;#过拟合为什么不好&quot; class=&quot;headerlink&quot; title=&quot;过拟合为什么不好&quot;&gt;&lt;/a&gt;过拟合为什么不好&lt;/h3&gt;&lt;p&gt;比如我们想预测匹兹堡市的年收入情况，但是我们只采访了匹兹堡大学周围的人，没有采访别的人，我们在用这部分数据预测的时候，预测匹兹堡大学周围的生日当然是可以的，但是想预测整个匹兹堡的收入呢？自然不行。数据并没有代表性，或者说数据的有些维度在测试集是可以帮助达到global optimal，但是在unseen dataset中并没有卵用，导致了模型没有泛化能力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/23/regularize-1/overfitting.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>OpenMP</title>
    <link href="https://hzjry123.github.io/2018/02/23/openmp/"/>
    <id>https://hzjry123.github.io/2018/02/23/openmp/</id>
    <published>2018-02-23T13:13:20.000Z</published>
    <updated>2018-03-06T01:41:14.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h1><p>Designed for a shared memory system.</p><p>Every process can access to all avaiable memory.</p><p><img src="/2018/02/23/openmp/share.png" alt=""></p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"The output:\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel num_threads(3)</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Hello World\n"</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">/* Resume Serial section*/</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"Done\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会把OpenMP代码编译为pthread</p><p>有一个Master thread, 创建一系列slaves</p><h2 id="Most-basic-parallel-directive"><a href="#Most-basic-parallel-directive" class="headerlink" title="Most basic parallel directive:"></a>Most basic parallel directive:</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br></pre></td></tr></table></figure><h2 id="Clause"><a href="#Clause" class="headerlink" title="Clause"></a>Clause</h2><p>#pragma omp parallel后面的东西</p><p>比如#pragma omp parallel num_threads(3)</p><h2 id="防止race-condition"><a href="#防止race-condition" class="headerlink" title="防止race condition"></a>防止race condition</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">global_result = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">double</span> my_result = Trap(a, b, n);</span><br><span class="line"> pragma omp critical</span><br><span class="line"> global_result += my_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Scope-of-variable"><a href="#Scope-of-variable" class="headerlink" title="Scope of variable:"></a>Scope of variable:</h2><p>可以被所有线程操作的变量：share scope（默认情况）</p><p>只能被单个线程才操作的变量：private scope</p><h2 id="Reduction-operators"><a href="#Reduction-operators" class="headerlink" title="Reduction operators:"></a>Reduction operators:</h2><p>定义：binary operation，+, *, -, &amp;, |, ˆ, &amp;&amp;, || </p><p>reduction(\<operator>: \<variable list="">)</variable></operator></p><p>可以被加入到clause里面</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">global_result = <span class="number">0.0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel reduction(+: global_result)</span></span><br><span class="line">global_result += Trap(a, b, n);</span><br></pre></td></tr></table></figure><h2 id="Parallel-For"><a href="#Parallel-For" class="headerlink" title="Parallel For"></a>Parallel For</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">h = (b-a)/n;</span><br><span class="line">approx = (f(a) + f(b)) / <span class="number">2.0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reduction(+: approx)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line"> approx += f(a + i*h);</span><br><span class="line">approx = h*approx;</span><br></pre></td></tr></table></figure><h2 id="Data-dependencies"><a href="#Data-dependencies" class="headerlink" title="Data dependencies"></a>Data dependencies</h2><p>斐波那契数列：</p><p><img src="/2018/02/23/openmp/dp.png" alt=""></p><p>OpenMp不会去检查iteration之间的数据依赖！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;OpenMP&quot;&gt;&lt;a href=&quot;#OpenMP&quot; class=&quot;headerlink&quot; title=&quot;OpenMP&quot;&gt;&lt;/a&gt;OpenMP&lt;/h1&gt;&lt;p&gt;Designed for a shared memory system.&lt;/p&gt;
&lt;p&gt;Every process can access to all avaiable memory.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/02/23/openmp/share.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="并行编程" scheme="https://hzjry123.github.io/tags/%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>google cloud configuration and jupyter</title>
    <link href="https://hzjry123.github.io/2018/02/15/google-cloud-configuration/"/>
    <id>https://hzjry123.github.io/2018/02/15/google-cloud-configuration/</id>
    <published>2018-02-15T17:28:32.000Z</published>
    <updated>2018-03-22T22:09:35.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><p>最近学习了机器学习的算法基础，也实践过很多小数据的数据分析，因此对大数据的分析产生了兴趣，想部署一个spark集群去学习大数据，发现aws虽然免费但是挺坑的，只有1g memory。偶然了解到google cloud，听说google cloud给注册用户赠送有效期为一年的300刀抵用券，而且在google cloud上部署hadoop集群或者高性能机器都很方便。</p><p>jupyter notebook + pyspark: spark上提供了很多机器学习的算法，而且支持集群计算。加上jupyter notebook这种直观的可视化界面，更加方便。而且jupyter notebook作为一个web application，完全可以在google cloud上运行，将端口映射到本机后，用户则可以直接使用高性能集群上的jupyter notebook可以直接关注算法本身而不用去考虑集群的配置，可以说是数据分析的很好的工具了。</p><a id="more"></a><h1 id="Google-cloud网页配置"><a href="#Google-cloud网页配置" class="headerlink" title="Google cloud网页配置"></a>Google cloud网页配置</h1><p>Google cloud基于google cloud sdk，可以下载cloud sdk在本机上使用命令<code>gcloud</code>，同时google cloud也提供了网页版的shell，也很方便。</p><p>推荐大家先在网页上注册google cloud，填写支付信息（必须有可以支付美元的信用卡）然后按照流程去走一遍（创建自己的instance，部署一个app，看谷歌炫技）。过程中会创建自己的project，记下id。</p><h2 id="下载google-cloud-sdk"><a href="#下载google-cloud-sdk" class="headerlink" title="下载google cloud sdk"></a>下载google cloud sdk</h2><p><a href="https://cloud.google.com/sdk/downloads" target="_blank" rel="noopener">https://cloud.google.com/sdk/downloads</a></p><p>按照网页上的步骤安装就可以了，十分方便。安装成功会让你登陆谷歌账号和配置一些instance的环境。</p><h2 id="配置集群和jupyter"><a href="#配置集群和jupyter" class="headerlink" title="配置集群和jupyter"></a>配置集群和jupyter</h2><p>这一步是在本机上执行</p><p>然后就可以配置你的hadoop cluster了。我推荐在本地的terminal里配置。输入如下命令（创建cluster并配置安装jupyter）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gcloud dataproc clusters create cluster-name \</span><br><span class="line">    --project project-id \</span><br><span class="line">    --master-machine-type n1-standard-2 \</span><br><span class="line">    --worker-machine-type n1-standard-2 \</span><br><span class="line">    --initialization-actions \</span><br><span class="line">        gs://dataproc-initialization-actions/jupyter/jupyter.sh</span><br></pre></td></tr></table></figure><p>其中\是换行标志，— 后面跟的是属性，在这里我标注了使用的Master和salve的型号，如果不标注则无法运行，（因为默认的配置会使你的钱包溢出了）。这里配置好了待会也可以去网页上更改配置，因为这里是500g的硬盘，一般用不了这么大。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gs:<span class="regexp">//</span>dataproc-initialization-actions<span class="regexp">/jupyter/</span>jupyter.sh</span><br></pre></td></tr></table></figure><p>gs：github shell，执行GitHub的shell，这是按照jupyter、anaconda和spark的脚本。</p><h2 id="Pip版本升级"><a href="#Pip版本升级" class="headerlink" title="Pip版本升级"></a>Pip版本升级</h2><p>这一步是在网页上的Master的shell里执行。（master的ssh）</p><p>首先要更改脚本装的conda的权限</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line"><span class="keyword">cd</span> /<span class="keyword">opt</span></span><br><span class="line">chmod -R <span class="symbol">&lt;user_name&gt;</span> conda/</span><br></pre></td></tr></table></figure><p>然后再切换回自己的用户</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">exit</span></span><br></pre></td></tr></table></figure><p>pip是python里包下载工具，最好升级一下不然会出现很多怪错误。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">conda update pip</span></span><br></pre></td></tr></table></figure><h2 id="连接jupyter"><a href="#连接jupyter" class="headerlink" title="连接jupyter"></a>连接jupyter</h2><p>这一步确实有很多坑啊，参考了很多命令才得以使用。</p><h2 id="防火墙设置"><a href="#防火墙设置" class="headerlink" title="防火墙设置"></a>防火墙设置</h2><p>可以直接在google cloud的搜索栏里搜firewall rules。</p><p>再去里面创建firewall rules。填写如下配置</p><p><img src="/2018/02/15/google-cloud-configuration/fire_wall.detail.png" alt=""></p><p>其中的tcp:5000是声明通过ipv6连接cluster，同时这个5000也是我们启动jupyter的端口，接下来本机要通过映射去得到这个5000端口。</p><h2 id="jupyter的启动"><a href="#jupyter的启动" class="headerlink" title="jupyter的启动"></a>jupyter的启动</h2><p>这一步是在网页上的Master后ssh的terminal里执行。</p><p>对于jupyter的一些概念，在哪个路径下启动jupyter notebook，打开的默认位置就是那个路径。有点类似于先选定project的位置，再打开编译器。</p><p>我们最好不要直接在根目录下启动jupyter，会产生一些怪问题，最好是找到自己用户的路径然后自己mkdir一个路径去做jupyter，5000是刚设置的端口。</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">jupyter</span><span class="literal">-</span><span class="comment">notebook</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">no</span><span class="literal">-</span><span class="comment">browser</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port=5000</span></span><br></pre></td></tr></table></figure><p>会产生一个token给你，</p><h1 id="本机terminal配置"><a href="#本机terminal配置" class="headerlink" title="本机terminal配置"></a>本机terminal配置</h1><h2 id="本地映射服务器端口"><a href="#本地映射服务器端口" class="headerlink" title="本地映射服务器端口"></a>本地映射服务器端口</h2><p>这一步是在本机terminal执行</p><p>在这一步确实会有很多幺蛾子。先说我的方法吧：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute ssh <span class="tag">&lt;<span class="name">master</span>&gt;</span> -- -L <span class="tag">&lt;<span class="name">your</span> <span class="attr">port</span>&gt;</span>:127.0.0.1:<span class="tag">&lt;<span class="name">jupyter</span> <span class="attr">port</span>&gt;</span> -N -n <span class="tag">&lt;<span class="name">master</span>&gt;</span></span><br></pre></td></tr></table></figure><p>example</p><p>我是映射到了本机的1024端口，只要那里没有端口占用就行了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute ssh tianchi-m -- -L 1024:127.0.0.1:5001 -N -n tianchi-m</span><br></pre></td></tr></table></figure><p>记得Master后面都跟一个-m的，也就是clustername-m。</p><p>然后登陆<code>localhost:1024</code>就可以看见我们的jupyter了。第一次登陆一般要输入token。在网页上的terminal里有，复制过来输入就好。</p><p><img src="/2018/02/15/google-cloud-configuration/token.png" alt=""></p><p>成功启动：</p><p><img src="/2018/02/15/google-cloud-configuration/jupyter.png" alt=""></p><p>官方的办法:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute ssh cluster-name-m -- -L 1080:cluster-name-m:8088 -N -n</span><br></pre></td></tr></table></figure><h2 id="SSH-Tunel"><a href="#SSH-Tunel" class="headerlink" title="SSH Túnel"></a>SSH Túnel</h2><p>还有一种方法是开一个ssh tunel, 再启动有代理的chrome，这样的好处是可以看全部的webui。包括jupyter，spark，hadoop。</p><h3 id="开启Tunel"><a href="#开启Tunel" class="headerlink" title="开启Tunel"></a>开启Tunel</h3><p>规范：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcloud compute ssh --zone=master-host-zone master-host-name -- \</span><br><span class="line">  -D <span class="number">1080</span> -<span class="built_in">N</span> -<span class="built_in">n</span></span><br><span class="line">  -D表示动态ip，<span class="number">1080</span>是本地端口，—<span class="built_in">N</span>是不开启远程shell？ -<span class="built_in">n</span>是std标准输出</span><br></pre></td></tr></table></figure><p>我的</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">gcloud</span> <span class="comment">compute</span> <span class="comment">ssh</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">zone=us</span><span class="literal">-</span><span class="comment">east1</span><span class="literal">-</span><span class="comment">c</span> <span class="comment">tianchi</span><span class="literal">-</span><span class="comment">m</span> <span class="literal">-</span><span class="literal">-</span> <span class="comment">\</span></span><br><span class="line"><span class="comment"></span>  <span class="literal">-</span><span class="comment">D</span> <span class="comment">1080</span> <span class="literal">-</span><span class="comment">N</span> <span class="literal">-</span><span class="comment">n</span></span><br></pre></td></tr></table></figure><h3 id="设置chrome的代理"><a href="#设置chrome的代理" class="headerlink" title="设置chrome的代理"></a>设置chrome的代理</h3><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Google Chrome executable path \</span><br><span class="line">  -<span class="ruby">-proxy-server=<span class="string">"socks5://localhost:1080"</span> \</span></span><br><span class="line"><span class="ruby">  --host-resolver-rules=<span class="string">"MAP * 0.0.0.0 , EXCLUDE localhost"</span> \</span></span><br><span class="line"><span class="ruby">  --user-data-dir=<span class="regexp">/tmp/master</span>-host-name</span></span><br></pre></td></tr></table></figure><ul><li><code>-proxy-server=&quot;socks5://localhost:1080&quot;</code> tells Chrome to send all <code>http://</code> and <code>https://</code> URL requests through the SOCKS proxy server localhost:1080, using version 5 of the SOCKS protocol. Hostnames for these URLs are resolved by the proxy server, not locally by Chrome.</li><li><code>--host-resolver-rules=&quot;MAP * 0.0.0.0 , EXCLUDE localhost&quot;</code> prevents Chrome from sending any DNS requests over the network.</li><li><code>--user-data-dir=/tmp/hadoop-master-name</code> forces Chrome to open a new window that is not tied to an existing Chrome session. Without this flag, Chrome may open a new window attached to an existing Chrome session, ignoring your <code>--proxy-server</code> setting. The value set for <code>--user-data-dir</code> can be any nonexistent path.</li></ul><p>Chrome path:</p><div class="table-container"><table><thead><tr><th>Operating System</th><th>Google Chrome Executable Path</th></tr></thead><tbody><tr><td>Mac OS X</td><td><code>/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome</code></td></tr><tr><td>Linux</td><td><code>/usr/bin/google-chrome</code></td></tr><tr><td>Windows</td><td><code>C:\Program Files (x86)\Google\Chrome\Application\chrome.exe</code></td></tr></tbody></table></div><p>我的</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/Applications/Google</span>\ Chrome.app/Contents/MacOS/Google\ Chrome \  <span class="params">--proxy-server=</span><span class="string">"socks5://localhost:1080"</span> \</span><br><span class="line"><span class="params">--host-resolver-rules=</span><span class="string">"MAP * 0.0.0.0 , EXCLUDE localhost"</span> \</span><br><span class="line"><span class="params">--user-data-dir=/tmp/tianchi-m</span></span><br></pre></td></tr></table></figure><p>连接成功</p><p><img src="/2018/02/15/google-cloud-configuration/spark.png" alt=""></p><p>注：在连接jupyter的时候，主机名就不是tianchi-m了，是localhost。而别的webui都是你的cluster master name。</p><h1 id="别的连接-参考方法链接"><a href="#别的连接-参考方法链接" class="headerlink" title="别的连接/参考方法链接:"></a>别的连接/参考方法链接:</h1><p><a href="https://cloud.google.com/dataproc/docs/concepts/accessing/cluster-web-interfaces" target="_blank" rel="noopener">https://cloud.google.com/dataproc/docs/concepts/accessing/cluster-web-interfaces</a></p><p><a href="https://cloud.google.com/blog/big-data/2017/02/google-cloud-platform-for-data-scientists-using-jupyter-notebooks-with-apache-spark-on-google-cloud" target="_blank" rel="noopener">https://cloud.google.com/blog/big-data/2017/02/google-cloud-platform-for-data-scientists-using-jupyter-notebooks-with-apache-spark-on-google-cloud</a></p><p><a href="https://towardsdatascience.com/running-jupyter-notebook-in-google-cloud-platform-in-15-min-61e16da34d52" target="_blank" rel="noopener">https://towardsdatascience.com/running-jupyter-notebook-in-google-cloud-platform-in-15-min-61e16da34d52</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介：&quot;&gt;&lt;a href=&quot;#简介：&quot; class=&quot;headerlink&quot; title=&quot;简介：&quot;&gt;&lt;/a&gt;简介：&lt;/h1&gt;&lt;p&gt;最近学习了机器学习的算法基础，也实践过很多小数据的数据分析，因此对大数据的分析产生了兴趣，想部署一个spark集群去学习大数据，发现aws虽然免费但是挺坑的，只有1g memory。偶然了解到google cloud，听说google cloud给注册用户赠送有效期为一年的300刀抵用券，而且在google cloud上部署hadoop集群或者高性能机器都很方便。&lt;/p&gt;
&lt;p&gt;jupyter notebook + pyspark: spark上提供了很多机器学习的算法，而且支持集群计算。加上jupyter notebook这种直观的可视化界面，更加方便。而且jupyter notebook作为一个web application，完全可以在google cloud上运行，将端口映射到本机后，用户则可以直接使用高性能集群上的jupyter notebook可以直接关注算法本身而不用去考虑集群的配置，可以说是数据分析的很好的工具了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>GFS Reading Note</title>
    <link href="https://hzjry123.github.io/2018/02/03/GFS-Reading-Note/"/>
    <id>https://hzjry123.github.io/2018/02/03/GFS-Reading-Note/</id>
    <published>2018-02-03T18:26:40.000Z</published>
    <updated>2018-02-04T07:41:31.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GFS-阅读笔记"><a href="#GFS-阅读笔记" class="headerlink" title="GFS 阅读笔记"></a>GFS 阅读笔记</h1><p>GFS这篇paper可以说十分经典，在云计算课程上，老师要求我们去阅读这篇论文，由于GFS的篇幅很长、涵盖的面很多，我参考了网上许多的阅读笔记和原文，做了如下的记录和总结。</p><h2 id="1-GFS是什么？"><a href="#1-GFS是什么？" class="headerlink" title="1. GFS是什么？"></a>1. GFS是什么？</h2><p>GFS(Google File System)是一个大规模,具有高拓展性(scalable)的分布式系统，分布式集群是建立在大量的普通硬件上的，有很强的fault tolerance，能够响应大量的客户端。</p><a id="more"></a><h3 id="GFS设计需求"><a href="#GFS设计需求" class="headerlink" title="GFS设计需求"></a>GFS设计需求</h3><ol><li>建立在大量的便宜硬件上，因此必须有极强的监控、监测、恢复、容错机制</li><li>存储<strong>大</strong>数据(Multi-GB)</li><li>read操作: <ul><li>针对大文件, 流式读取连续文件. (100+KBs, 1MB or more)</li><li>针对小文件, 随机在不同的位置读取. (Few KBs)</li></ul></li><li>大的顺序写入多, 但是数据更改少.</li><li>高并发性(超多生产者, 超多消费者(同时从不同节点读文件))</li><li>保证高带宽(bandwidth)而非低延迟(大量用户注重读写速度而非响应时间)</li></ol><h3 id="GFS-API"><a href="#GFS-API" class="headerlink" title="GFS API"></a>GFS API</h3><p>Create, delete, open, close, read, write,record append(追加写), snapshot(文件快照)</p><h2 id="2-GFS架构"><a href="#2-GFS架构" class="headerlink" title="2. GFS架构"></a>2. GFS架构</h2><p>Single master, many chunkservers and clients.</p><p><img src="/2018/02/03/GFS-Reading-Note/Architecture.png" alt=""></p><h3 id="GFS特点概述"><a href="#GFS特点概述" class="headerlink" title="GFS特点概述"></a>GFS特点概述</h3><ul><li>文件按fix-size chunk存储, 每个chunk在创建时有一个不可改变的64位的标识符, 一个chunk有三个备份.</li><li>Master存储所有的 metadata, 其包括namespace, access control, 文件与chunk的mapping, chunk的位置.</li><li>Master管理chunk的lease, gc, migration. Master通过<em>HeatBeat</em>来向节点传递信息和节点的状态检查.</li><li>client向Master请求metadata操作chunk server</li><li>client和server都不缓存文件数据(保证数据一致性). 但client会缓存metadata</li></ul><h3 id="Single-Master"><a href="#Single-Master" class="headerlink" title="Single Master"></a>Single Master</h3><p>GFS为了简化设计, 在整个系统中只有一个Master, 为保证性能Master也不提供读写操作给client, 只通知在哪里读取。</p><p>e.g. Interaction for a simple read (Figure 1)</p><ol><li>client将应用程序请求的文件名、大小转换成chunk index, 然后将其擦混送给Master.</li><li>Master返回chunk handle和备份位置信息</li><li>Client将文件名和chunk index作为key, 返回信息作为value.</li><li>Client向备份之一的chunk server(一般是最近的)发送请求(chunk index, byte range)</li><li>在lease期限内, client都可以与chunkserver通信, 过期后要再向Master请求.(lease确实很厉害啊, 在后面会详细叙述)</li></ol><h3 id="Chunk-size"><a href="#Chunk-size" class="headerlink" title="Chunk size"></a>Chunk size</h3><p>64MB &gt;&gt; 一般文件系统块大小</p><p>Pros: </p><ul><li>减少client与Master交互(因为存在大量的连续存储, 因此大的块当然可以记录更多的信息)</li><li>client 可以在一个块上执行更多的操作, 减少了网络压力</li><li>减少了存储在Master上的Metadata的大小,这允许将Metadata存储在内存里</li></ul><p>Cons:</p><p>Hot Spot</p><ul><li>由于一个chunk可以存更多的小文件, 他的操作频率会变高,这会给chunk很大的压力(但是在实际中影响不大)</li><li>在批处理系统(batch-queue System)中, 一个chunk上的可执行文件要被许多client执行, overload啦. (解决办法是多加几个备份, 允许client去读别的client的文件)</li></ul><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><p>元数据存储了三类信息:</p><ol><li>文件和chunk的命名空间</li><li>文件与chunk的映射关系</li><li>备份的位置</li></ol><p>我们知道metadata存储在内存里, 有很多的有点, 但是会不会受限于内存大小呢？实际上不会的, 每个metadata少于64kb又能记录64MB的chunk信息, 然后内存又便宜(谷歌部署不了大量的高性能服务器,还升级不了内存？)</p><h3 id="chunk的位置"><a href="#chunk的位置" class="headerlink" title="chunk的位置"></a>chunk的位置</h3><p>chunk的位置信息是定期通过heartbeat更新的, 这样减少了与chunkserver和Master时刻通信的代价。</p><p>当然每个chunkserver都有一个final word, 记录那些他有哪些chunk, 而哪些chunk又不在了.</p><h3 id="Operation-Log"><a href="#Operation-Log" class="headerlink" title="Operation Log"></a>Operation Log</h3><p>我们都知道log这种东西在任何系统里都是十分重要的, 在GFS也是, </p><ul><li>因为他是在gfs里唯一记录了所有metadata所有的信息的东西.</li><li>而且记录了操作的时间线, 这在回复过程中是十分关键的.</li></ul><p>checkpoint记录在一个类似B-Tree的结果里</p><h3 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h3><h5 id="这部分很重要"><a href="#这部分很重要" class="headerlink" title="这部分很重要"></a>这部分很重要</h5><p>如何保证：文件命名空间的变化是原子性的(atomic), 命名空间锁.</p><h5 id="GFS定义的概念："><a href="#GFS定义的概念：" class="headerlink" title="GFS定义的概念："></a>GFS定义的概念：</h5><ul><li>如果所有客户端从任意备份读取相同文件, 得到相同结果, 则改文件是一致的</li><li>defined: 如果一个文件区域在经过一系列操作之后依旧是一只的,并且所有客户端完全知道操作过程,。</li><li>如果一个操作没有被其他并发进程干扰, 那文件区域是defined的.</li><li>如果所有客户端没有知道一个并发操作的过程,但是该并发操作的结果是一致的,那么该文件区域是undefined的.</li><li>失败的并发操作不用说,是不一致的,操作的文件区域也是undefined的.</li></ul><h5 id="造成数据的改变："><a href="#造成数据的改变：" class="headerlink" title="造成数据的改变："></a>造成数据的改变：</h5><p>write and record append(no overwrite)</p><h5 id="GFS保证一致性的办法"><a href="#GFS保证一致性的办法" class="headerlink" title="GFS保证一致性的办法:"></a>GFS保证一致性的办法:</h5><ol><li><p>在所有备份机上执行相同的操作顺序.</p></li><li><p>使用chunk version来监测任何过期的备份, 过期的备份就被gc了</p><p>但如果不小心读取到了过期的呢?比如因为信息没被更新, 没事, 由于只有追加写, 大家差不多都一样麦。当收到Master的信息的时候,再去新的chunk也不迟</p></li><li><p>通过handshake来检查宕机的服务器(和heartbeat有什么不同呢？)</p></li><li><p>通过checksum来保证文件完整性。</p></li></ol><h2 id="3-系统交互"><a href="#3-系统交互" class="headerlink" title="3. 系统交互"></a>3. 系统交互</h2><p>在这一部分, 我们来看GFS为了保证让Master介入最少, 如何去设计client, Master和 chunkservers 之间交互, 以及数据修改, 原子操作和快照. </p><h5 id="Lease-and-Mutation-order"><a href="#Lease-and-Mutation-order" class="headerlink" title="Lease and Mutation order"></a>Lease and Mutation order</h5><p>定义:</p><p>Primary(主席):  Master(中央)把lease发给replica中的一个(被钦定), 然后改node就要开始选定一个执行顺序,让别的replicas一起执行. 每个lease60秒的有效期(time out), </p><h6 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题:"></a>常见问题:</h6><p>Q: 如果Master联系不到primary怎么办？</p><p>A: 在现有协议结束后,Master会钦定一个新的replica.</p><p>Q: 要是Master要停止这个操作怎么办? </p><p>A: 提前解约这个lease.</p><p><img src="/2018/02/03/GFS-Reading-Note/figure2.png" alt=""></p><p>过程解读:</p><ol><li>Client向Master请求持有的lease的chunk(primary replica)位置和其他replicas的位置. 如果没有主席, Master就钦定一个.</li><li>Master告知client主席的信息和replica的信息,然后client将信息缓存.(当primary无法通信或者primary replica没有lease了,client才会向Master再次请求)</li><li>client会把数据发送到所有的replicas,大家存在LRU缓存里.</li><li>在大家都收到数据之后,client会向primary发送写请求,primary给mutation分配序号(mutation可能来自不同的client),然后执行</li><li>primary发送给大家序号,大家也按序号执行.</li><li>告诉主席做完了</li><li>主席回复client完成的状态或者错误,client的error handler会重试失败的mutation.</li></ol><h3 id="Data-Flow"><a href="#Data-Flow" class="headerlink" title="Data Flow"></a>Data Flow</h3><p>设计目标:</p><ul><li>充分利用网络带宽(network bandwidth)</li><li>避免网络瓶颈和高延迟</li><li>减少数据流动的延迟</li></ul><p>设计方案:</p><ul><li>数据在chunkserver中线性流动(而非类似树的结构). 每个机器都在用自己的全部带宽与另外一个机器通信.</li><li>每个机器会把数据发送到还没收到数据且离自己最近的机器中(距离通过ip地址计算)</li><li>通过TCP连接将数据传输流水线化(pipelining),之所以如此有效是因为GFS使用全双工的交换网络(switched network with full-duplex links)</li></ul><h3 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h3><p>GFS通过snapshot来瞬间创建一个文件的备份或者一个目录树的备份, 应用了copy-on-write(在没有更改的时候,只用指针指向同样的文件)</p><p>当Master收到snapshot操作请求后:</p><ol><li>废除所有lease,暂停所有写操作.</li><li>Master记录所有操作,记录写入磁盘.</li><li>Master将源文件和目录树的metadata进行复制,这样之前的记录和当前内存中所保存的状态就对应起来了,新建的snapshot和源文件指向的会是同一个chunk</li></ol><h2 id="4-Master职责"><a href="#4-Master职责" class="headerlink" title="4. Master职责"></a>4. Master职责</h2><ul><li>执行所有关于namespace的操作</li><li>管理chunk replicas:<ul><li>做出chunk, replica放置决定</li><li>创建chunk, replica</li><li>协调各种活动, 保证chunk完全复制</li><li>负载均衡</li><li>回收闲置空间</li></ul></li></ul><h3 id="管理namespace"><a href="#管理namespace" class="headerlink" title="管理namespace"></a>管理namespace</h3><p>就是用读写锁来保证顺序执行。</p><h3 id="放置replicas"><a href="#放置replicas" class="headerlink" title="放置replicas"></a>放置replicas</h3><ul><li>最大化数据可靠性以及可用性</li><li>最大化带宽的利益</li></ul><p>要考虑到机架(rack)间的问题,将数据存放到不同的机架上,当一个机架宕机之后,别的机架还可以用.</p><p>这样对于一个chunk,可以利用多个机架的带宽,对于写的竞争,由于有好几个机架要去写,这样就达成了一个tradeoff！</p><h3 id="创建replica"><a href="#创建replica" class="headerlink" title="创建replica"></a>创建replica</h3><p>创建的三个情况:</p><ul><li>创建新的chunk</li><li>重新备份</li><li>重新负载均衡</li></ul><p>如何选择放到哪个机器？放置规则</p><ul><li>优先利用磁盘利用率低的chunkserver.</li><li>限制每个chunkserver的”recent” creations, 因为创建要写,而大量写会造成traffic, 降低效率, 这是我们不希望看见的.</li><li>跨机架进行放置</li></ul><p>当有多个chunk需要备份,要考虑优先级的问题:</p><ul><li>基于replication goal: 可用备份少的先.</li><li>活着的比最近删除的先.</li><li>阻塞client过程优先</li></ul><p>决定备份哪个之后, clone可用chunk到目标位置(遵循放置规则)</p><h3 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h3><p>在GFS里,如果文件删除之后,GFS不会马上对其进行回收,而是要等待垃圾回收机制对其空间进行释放.这感觉是GFS的一个骚想法.为什么要这么做呢？在后面给出了部分的理由,看起来还是十分合理有效,开拓思路的.</p><p>GFS删除文件的策略:</p><ol><li>记录删除操作,将此文件命名为hidden+时间戳.</li><li>Master定期进行扫描,把隐藏了一段时间的空间回收, GFS设置为三天(这会产生问题,在后文会陈述)</li><li>在此期间,GFS可以对这个空间进行恢复, 改一个名字就好.</li><li>同时GC还会找到孤儿chunk(没有文件用到的非空chunk),然后清理该chunk的metadata.(比如创建一半失败了)</li><li>通过与chunkserver的心跳信息,每一个chunkserver会返回他有的chunk的子集,然后Master就会告诉chunkserver哪些是metadata都没有的.chunkserver就会对其进行删除（比如删除一半失败了）</li></ol><p>讨论：</p><p>分布式系统的删和回收是很复杂的, 但在GFS里, 我们有replica的mapping. 这就省了不少事. </p><p>pros: </p><ul><li>由于出错是很常见的, 这样的gc机制省了master不少的事情.</li><li>把空间回收和日常的handshakes结合起来, 分摊了开销, 而且这只是在master不忙的时候做, 优先级是低于回复client. 相比于删除GFS还有更重要的事情.</li><li>避免了意外删除、无法重现的删除的情况.</li></ul><p>cons: </p><ul><li>无法很好的去响应user对于空间的调整, 比如没什么空间了, 想删点东西, 但是发现删了没用.</li><li>有些程序删除和创建很频繁, 这导致他们没法马上使用他们删除的文件空间.</li></ul><p>解决办法:</p><p>​    缩短删除时间, 允许读者自己定义. 例如一些目录下的就没有备份, 迅速删除, 释放空间.</p><h5 id="过期replica监测"><a href="#过期replica监测" class="headerlink" title="过期replica监测"></a>过期replica监测</h5><p>过期原因: chunkserver宕机, mutation丢失.</p><p>监测办法: 赋予chunk version number.</p><p>当Master给出新的lease的时候,会增加版本号并通知replicas去更新版本号, Master和replicas都会记录新版本号. </p><ul><li>如果这是有一个replica不可用了, 那他的版本号自然就不好更新, 在chunkserver重启或者向Master报告的时候, Master就知道你过期了, 并用GC回收</li><li>如果是Master版本号落后, Master会更新自己的版本号.</li></ul><h2 id="5-高可用性"><a href="#5-高可用性" class="headerlink" title="5. 高可用性"></a>5. 高可用性</h2><p>在上百个GFS服务器里, 有些可能随时会不可用. GFS有两个策略: fast recovery和 replication</p><h3 id="Fast-Recovery"><a href="#Fast-Recovery" class="headerlink" title="Fast Recovery"></a>Fast Recovery</h3><p>不管是什么原因导致的宕机, 马上重启. GFS甚至不会去管是不是异常宕机.</p><h3 id="Chunk-Replication"><a href="#Chunk-Replication" class="headerlink" title="Chunk Replication"></a>Chunk Replication</h3><p>前面说过了</p><h3 id="Master-Replication"><a href="#Master-Replication" class="headerlink" title="Master Replication"></a>Master Replication</h3><p>虽然只有一个Master, 但是Master的log和checkpoint还是存储在多个机器上. </p><p>一个mutation只有在Master和他的备份们都记录了之后才被视作完成.</p><p>当Master宕机之后, 可以用他的备份去重启一个Master. 但是client怎么知道你是新Master呢? 首先新老Master的名字是一样的, 要改的只不过是DNS而已.</p><p>由于新Master只是shadow Master 不是热备份的镜像Master, 因此他们只提供读的权限！</p><p>后面就是性能测试了, 就没有再看下去. 吐槽一下这论文实在太夸张了.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;GFS-阅读笔记&quot;&gt;&lt;a href=&quot;#GFS-阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;GFS 阅读笔记&quot;&gt;&lt;/a&gt;GFS 阅读笔记&lt;/h1&gt;&lt;p&gt;GFS这篇paper可以说十分经典，在云计算课程上，老师要求我们去阅读这篇论文，由于GFS的篇幅很长、涵盖的面很多，我参考了网上许多的阅读笔记和原文，做了如下的记录和总结。&lt;/p&gt;
&lt;h2 id=&quot;1-GFS是什么？&quot;&gt;&lt;a href=&quot;#1-GFS是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. GFS是什么？&quot;&gt;&lt;/a&gt;1. GFS是什么？&lt;/h2&gt;&lt;p&gt;GFS(Google File System)是一个大规模,具有高拓展性(scalable)的分布式系统，分布式集群是建立在大量的普通硬件上的，有很强的fault tolerance，能够响应大量的客户端。&lt;/p&gt;
    
    </summary>
    
    
      <category term="ReadingNote" scheme="https://hzjry123.github.io/tags/ReadingNote/"/>
    
  </entry>
  
  <entry>
    <title>linkedlist and array</title>
    <link href="https://hzjry123.github.io/2018/02/02/linkedlist-and-array/"/>
    <id>https://hzjry123.github.io/2018/02/02/linkedlist-and-array/</id>
    <published>2018-02-02T15:20:00.000Z</published>
    <updated>2018-03-06T07:28:25.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="存取效率"><a href="#存取效率" class="headerlink" title="存取效率"></a>存取效率</h2><p>Array &gt; LinkedList</p><p>LinkedList要从头开始移动指针而Array是randomaccess</p><p>插入元素：LinkedList更灵活</p><h2 id="LinkedList练习"><a href="#LinkedList练习" class="headerlink" title="LinkedList练习"></a>LinkedList练习</h2><h3 id="Reverse-LinkedList"><a href="#Reverse-LinkedList" class="headerlink" title="Reverse LinkedList"></a>Reverse LinkedList</h3><p>翻转LinkedList</p><p>1-&gt;2-&gt;3-&gt;4-&gt;null</p><p>4-&gt;3-&gt;2-&gt;1-&gt;null</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//0-&gt;1-&gt;2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//0&lt;-1 2-&gt;3-&gt;4</span></span><br><span class="line"><span class="comment">//0&lt;-1&lt;-2 3-&gt;4-&gt;5</span></span><br><span class="line"><span class="comment">//0&lt;-1&lt;-2&lt;-3 4-&gt;5</span></span><br><span class="line"><span class="comment">//0&lt;-1&lt;-2&lt;-3&lt;-4 5</span></span><br><span class="line"><span class="comment">//0&lt;-1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">    <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="comment">//0&lt;-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5</span></span><br><span class="line">        <span class="comment">//0&lt;-&gt;1 2-&gt;3-&gt;4-&gt;5</span></span><br><span class="line">        <span class="comment">//0&lt;-&gt;1&lt;-2 3-&gt;4-&gt;5</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        ListNode pre = dummy;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0&lt;-&gt;1&lt;-2&lt;-3&lt;-4&lt;-5</span></span><br><span class="line">        <span class="comment">//head = 1,</span></span><br><span class="line">        <span class="comment">//prev = 5,cur = null</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Reverse-Linked-ListII"><a href="#Reverse-Linked-ListII" class="headerlink" title="Reverse Linked ListII"></a>Reverse Linked ListII</h3><p>Reverse a linked list from position m to n.</p><p><strong>Notice</strong></p><p>Given m, n satisfy the following condition: 1 ≤ m ≤ n ≤ length of list.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example</span><br><span class="line"></span><br><span class="line">Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2 and n = 4, return 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL.</span><br><span class="line"></span><br><span class="line">Challenge</span><br><span class="line"></span><br><span class="line">Reverse it in-place and in one-pass</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseBetween</span><span class="params">(ListNode head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6</span></span><br><span class="line">        <span class="comment">// m=2,n =4</span></span><br><span class="line">        <span class="comment">// prev = 1,cur = 2</span></span><br><span class="line">        <span class="comment">//   0-&gt;1&lt;- 2  3-&gt;4-&gt;5-&gt;6 start = 2, start_prev = 1</span></span><br><span class="line">        <span class="comment">// 2:0-&gt;1&lt;-&gt;2&lt;-3 4-&gt;5-&gt;6</span></span><br><span class="line">        <span class="comment">// 3:0-&gt;1&lt;-&gt;2&lt;-3&lt;-4 5-&gt;6</span></span><br><span class="line">        <span class="comment">// 4:0-&gt;1&lt;-&gt;2&lt;-3&lt;-4&lt;-5 6 prev = 5, cur = 6, s_prev.next -&gt; prev, start -&gt; cur</span></span><br><span class="line">        <span class="comment">// 5:0-&gt;1-&gt; 5-&gt;4-&gt;3-&gt;2-&gt;6</span></span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(head ==  <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode start_prev = dummy;</span><br><span class="line">        <span class="comment">//find start_prev. e.g:m = 1, start_prev = 0,start = 1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            start_prev = start_prev.next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode start = start_prev.next;</span><br><span class="line">        ListNode cur = start;</span><br><span class="line">        ListNode prev = start_prev;</span><br><span class="line">        <span class="comment">//start reverse n = 3.n-m = 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="comment">// 2:0-&gt;1-&gt;2&lt;-3 4-&gt;5-&gt;6</span></span><br><span class="line">            ListNode temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4:0-&gt;1&lt;-&gt;2&lt;-3&lt;-4&lt;-5 6 prev = 5, cur = 6, s_prev.next -&gt; prev, start -&gt; cur</span></span><br><span class="line">        <span class="comment">// 5:0-&gt;1-&gt; 5-&gt;4-&gt;3-&gt;2-&gt;6</span></span><br><span class="line">        start_prev.next = prev;</span><br><span class="line">        start.next = cur;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Reverse-Nodes-in-k-Group"><a href="#Reverse-Nodes-in-k-Group" class="headerlink" title="Reverse Nodes in k-Group"></a>Reverse Nodes in k-Group</h3><p>Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.</p><p>If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.</p><p>You may not alter the values in the nodes, only nodes itself may be changed.<br>Only constant memory is allowed.</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Example</span></span><br><span class="line">Given this linked list: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">For k = <span class="number">2</span>, you should <span class="keyword">return</span>: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span></span><br><span class="line"></span><br><span class="line">For k = <span class="number">3</span>, you should <span class="keyword">return</span>: <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        ListNode prev = dummy;</span><br><span class="line">        <span class="comment">// 0-&gt; 1-&gt;2-&gt;3-&gt;4-&gt;5 </span></span><br><span class="line">        <span class="comment">// 0 </span></span><br><span class="line">        <span class="keyword">while</span>(prev != <span class="keyword">null</span>)&#123;</span><br><span class="line">            prev = reverseKNode(prev,k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;5 prev = 0, cur = 1</span></span><br><span class="line">    <span class="comment">// 0&lt;-&gt;1 2-&gt;3-&gt;4-&gt;5 start for</span></span><br><span class="line">    <span class="comment">// 0&lt;-&gt;1&lt;-2 3-&gt;4-&gt;5 end for prev = 2, cur = 3</span></span><br><span class="line">    <span class="comment">// 0-&gt;2-&gt;1-&gt;3-&gt;4-&gt;5 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKNode</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        ListNode last = head.next;</span><br><span class="line">        ListNode prev = head;</span><br><span class="line">        ListNode cur = head.next;</span><br><span class="line">        ListNode temp = <span class="keyword">null</span>;</span><br><span class="line">        ListNode nk = head;</span><br><span class="line">        <span class="comment">//0-&gt;1-&gt;2 nk to 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k; i++)&#123;</span><br><span class="line">            nk = nk.next;</span><br><span class="line">            <span class="keyword">if</span>(nk == <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//0&lt;-&gt;1&lt;-2 3-&gt;4-&gt;5 cur = 3, prev = 2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            temp = cur.next;</span><br><span class="line">            cur.next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 0-&gt;2-&gt;1-&gt;3-&gt;4-&gt;5  1=last, head.next-&gt;prev, </span></span><br><span class="line">        head.next = nk;<span class="comment">//nk == prev</span></span><br><span class="line">        last.next = cur;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;存取效率&quot;&gt;&lt;a href=&quot;#存取效率&quot; class=&quot;headerlink&quot; title=&quot;存取效率&quot;&gt;&lt;/a&gt;存取效率&lt;/h2&gt;&lt;p&gt;Array &amp;gt; LinkedList&lt;/p&gt;
&lt;p&gt;LinkedList要从头开始移动指针而Array是randomaccess&lt;/p&gt;
&lt;p&gt;插入元素：LinkedList更灵活&lt;/p&gt;
&lt;h2 id=&quot;LinkedList练习&quot;&gt;&lt;a href=&quot;#LinkedList练习&quot; class=&quot;headerlink&quot; title=&quot;LinkedList练习&quot;&gt;&lt;/a&gt;LinkedList练习&lt;/h2&gt;&lt;h3 id=&quot;Reverse-LinkedList&quot;&gt;&lt;a href=&quot;#Reverse-LinkedList&quot; class=&quot;headerlink&quot; title=&quot;Reverse LinkedList&quot;&gt;&lt;/a&gt;Reverse LinkedList&lt;/h3&gt;&lt;p&gt;翻转LinkedList&lt;/p&gt;
&lt;p&gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;null&lt;/p&gt;
&lt;p&gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;null&lt;/p&gt;
    
    </summary>
    
    
      <category term="Algorithm" scheme="https://hzjry123.github.io/tags/Algorithm/"/>
    
      <category term="LinkedList" scheme="https://hzjry123.github.io/tags/LinkedList/"/>
    
      <category term="Array" scheme="https://hzjry123.github.io/tags/Array/"/>
    
  </entry>
  
  <entry>
    <title>binary tree</title>
    <link href="https://hzjry123.github.io/2018/02/01/binary-tree/"/>
    <id>https://hzjry123.github.io/2018/02/01/binary-tree/</id>
    <published>2018-02-01T18:31:53.000Z</published>
    <updated>2018-03-06T07:35:51.371Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了关于二叉树的相关题目。</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历:"></a>先序遍历:</h4><ol><li>Divide &amp; Conquer  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        result.add(root.val);</span><br><span class="line">        List&lt;Integer&gt; left = preorderTraversal(root.left);</span><br><span class="line">        List&lt;Integer&gt; right = preorderTraversal(root.right);</span><br><span class="line">        result.addAll(left);</span><br><span class="line">        result.addAll(right);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ol><li>Traverse  </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        traverse(root, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root, ArrayList&lt;Integer&gt; result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result.add(root.val);</span><br><span class="line">        traverse(root.left, result);</span><br><span class="line">        traverse(root.right, result);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>比较分治法和遍历的区别：</p><p>遍历是没有返回值的，使用一个全局变量去记录数据。一个人拿本子去走</p><p>而分治法是有返回值的，分左右治之，再把左右值加进去。一个人去布置任务。</p><h4 id="Maximum-Depth-of-Binary-Tree"><a href="#Maximum-Depth-of-Binary-Tree" class="headerlink" title="Maximum Depth of Binary Tree **"></a>Maximum Depth of Binary Tree <a href="http://www.lintcode.com/en/problem/maximum-depth-of-binary-tree/#" target="_blank" rel="noopener">**</a></h4><p>Given a binary tree, find its maximum depth.   </p><p>The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.  </p><p><strong>Example</strong>  </p><p>Given a binary tree as follow:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span></span><br><span class="line"> / \ </span><br><span class="line"><span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">4</span>   <span class="number">5</span></span><br></pre></td></tr></table></figure><ol><li>Divide &amp; Conquer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> left = maxDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> right = maxDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> Math.max(left,right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Traverse</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> max;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">   max = <span class="number">0</span>;</span><br><span class="line">   helper(root,<span class="number">0</span>);</span><br><span class="line">   <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root, <span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    max = Math.max(max,++result);</span><br><span class="line">    helper(root.left,result);</span><br><span class="line">    helper(root.right,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Binary-Tree-Paths"><a href="#Binary-Tree-Paths" class="headerlink" title="Binary Tree Paths **"></a>Binary Tree Paths <a href="http://www.lintcode.com/en/problem/binary-tree-paths/#" target="_blank" rel="noopener">**</a></h4><p>Given a binary tree, return all root-to-leaf paths.    </p><p><strong>Example </strong> </p><p>Given the following binary tree:  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br></pre></td></tr></table></figure><p>All root-to-leaf paths are:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"1-&gt;2-&gt;5"</span>,</span><br><span class="line">  <span class="string">"1-&gt;3"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><ol><li>Divide &amp; Conquer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;   </span><br><span class="line">   List&lt;String&gt; my_result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> my_result;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; left = binaryTreePaths(root.left);</span><br><span class="line">    List&lt;String&gt; right = binaryTreePaths(root.right);</span><br><span class="line">    <span class="keyword">for</span>(String path : left)&#123;</span><br><span class="line">        my_result.add(root.val + <span class="string">"-&gt;"</span> + path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(String path : right)&#123;</span><br><span class="line">        my_result.add(root.val + <span class="string">"-&gt;"</span> + path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(my_result.size() == <span class="number">0</span>)<span class="comment">//叶子节点</span></span><br><span class="line">        my_result.add(root.val+<span class="string">""</span>);</span><br><span class="line">    <span class="keyword">return</span> my_result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>Traverse </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;String&gt; result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        helper(root,String.valueOf(root.val));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode root,String path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            result.add(path);</span><br><span class="line">        &#125;<span class="comment">//叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root.left != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.left, path + <span class="string">"-&gt;"</span> + String.valueOf(root.left.val));</span><br><span class="line">        <span class="keyword">if</span>(root.right != <span class="keyword">null</span>)</span><br><span class="line">            helper(root.right, path + <span class="string">"-&gt;"</span> + String.valueOf(root.right.val));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Minimum-Subtree"><a href="#Minimum-Subtree" class="headerlink" title="Minimum Subtree **:"></a>Minimum Subtree <a href="http://www.lintcode.com/en/problem/minimum-subtree/#" target="_blank" rel="noopener">**</a>:</h4><p>Given a binary tree, find the subtree with minimum sum. Return the root of the subtree.  </p><p><strong>Example</strong>  </p><p>Given a binary tree:  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /   \</span><br><span class="line"> <span class="number">-5</span>     <span class="number">2</span></span><br><span class="line"> / \   /  \</span><br><span class="line"><span class="number">0</span>   <span class="number">2</span> <span class="number">-4</span>  <span class="number">-5</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> TreeNode result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root.right);</span><br><span class="line">        <span class="keyword">int</span> sum = left + right +root.val;</span><br><span class="line">        <span class="keyword">if</span>(min &gt; sum)&#123;</span><br><span class="line">            min = sum;</span><br><span class="line">            result = root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>pure d-c</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode minSubtree;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> sum, minSum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResultType</span><span class="params">(TreeNode minSubtree, <span class="keyword">int</span> minSum, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.minSubtree = minSubtree;</span><br><span class="line">        <span class="keyword">this</span>.minSum = minSum;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">findSubtree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ResultType result = helper(root);</span><br><span class="line">        <span class="keyword">return</span> result.minSubtree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultType <span class="title">helper</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResultType(<span class="keyword">null</span>, Integer.MAX_VALUE, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ResultType leftResult = helper(node.left);</span><br><span class="line">        ResultType rightResult = helper(node.right);</span><br><span class="line">        </span><br><span class="line">        ResultType result = <span class="keyword">new</span> ResultType(</span><br><span class="line">            node,</span><br><span class="line">            leftResult.sum + rightResult.sum + node.val,</span><br><span class="line">            leftResult.sum + rightResult.sum + node.val</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (leftResult.minSum &lt;= result.minSum) &#123;</span><br><span class="line">            result.minSum = leftResult.minSum;</span><br><span class="line">            result.minSubtree = leftResult.minSubtree;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (rightResult.minSum &lt;= result.minSum) &#123;</span><br><span class="line">            result.minSum = rightResult.minSum;</span><br><span class="line">            result.minSubtree = rightResult.minSubtree;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Balanced-Binary-Tree"><a href="#Balanced-Binary-Tree" class="headerlink" title="Balanced Binary Tree **"></a>Balanced Binary Tree <a href="http://www.lintcode.com/en/problem/balanced-binary-tree/#" target="_blank" rel="noopener">**</a></h4><p>Given a binary tree, determine if it is height-balanced.  </p><p>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.  </p><p> <strong>Example</strong>  </p><p>Given binary tree A = <code>{3,9,20,#,#,15,7}</code>, B = <code>{3,#,20,15,7}</code>  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A)  <span class="number">3</span>            B)    <span class="number">3</span> </span><br><span class="line">   / \                  \</span><br><span class="line">  <span class="number">9</span>  <span class="number">20</span>                 <span class="number">20</span></span><br><span class="line">    /  \                / \</span><br><span class="line">   <span class="number">15</span>   <span class="number">7</span>              <span class="number">15</span>  <span class="number">7</span></span><br></pre></td></tr></table></figure><p>The binary tree A is a height-balanced binary tree, but B is not.  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> isb;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        isb = <span class="keyword">true</span>;</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> isb;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//return height</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || isb == <span class="keyword">false</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = helper(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = helper(root.right);</span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left - right) &gt; <span class="number">1</span>)</span><br><span class="line">            isb = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Subtree-with-Maximum-Average"><a href="#Subtree-with-Maximum-Average" class="headerlink" title="Subtree with Maximum Average **"></a>Subtree with Maximum Average <a href="http://www.lintcode.com/en/problem/subtree-with-maximum-average/#" target="_blank" rel="noopener">**</a></h4><p>Given a binary tree, find the subtree with maximum average. Return the root of the subtree.</p><p><strong>Example </strong>:</p><p>Given a binary tree:  </p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     <span class="number">1</span></span><br><span class="line">   /   \</span><br><span class="line"> <span class="number">-5</span>     <span class="number">11</span></span><br><span class="line"> / \   /  \</span><br><span class="line"><span class="number">1</span>   <span class="number">2</span> <span class="number">4</span>    <span class="number">-2</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">resultType</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> sum,num;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">resultType</span><span class="params">(TreeNode node, <span class="keyword">int</span> sum, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.sum = sum;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> resultType maxNode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">findSubtree2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        maxNode = <span class="keyword">new</span> resultType(<span class="keyword">null</span>,Integer.MIN_VALUE,<span class="number">1</span>);</span><br><span class="line">        helper(root);</span><br><span class="line">        <span class="keyword">return</span> maxNode.node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> resultType <span class="title">helper</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> resultType(<span class="keyword">null</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        resultType left = helper(root.left);</span><br><span class="line">        resultType right = helper(root.right);</span><br><span class="line">        resultType my_result = <span class="keyword">new</span> resultType(</span><br><span class="line">            root, </span><br><span class="line">            root.val + left.sum + right.sum, </span><br><span class="line">            left.num + right.num + <span class="number">1</span>);<span class="comment">//本题与左右的avg无关.</span></span><br><span class="line">        <span class="keyword">if</span>(my_result.sum * maxNode.num &gt; maxNode.sum * my_result.num )<span class="comment">//key point calculate avg;</span></span><br><span class="line">            maxNode = my_result;</span><br><span class="line">        <span class="keyword">return</span> my_result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Lowest-Common-Ancestor"><a href="#Lowest-Common-Ancestor" class="headerlink" title="Lowest Common Ancestor **"></a>Lowest Common Ancestor <a href="http://www.lintcode.com/en/problem/lowest-common-ancestor/#" target="_blank" rel="noopener">**</a></h4><p>Given the root and two nodes in a Binary Tree. Find the lowest common ancestor(LCA) of the two nodes.</p><p>The lowest common ancestor is the node with largest depth which is the ancestor of both nodes.</p><p>Example</p><p>For the following binary tree:</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">4</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">3</span>   <span class="number">7</span></span><br><span class="line">   / \</span><br><span class="line">  <span class="number">5</span>   <span class="number">6</span></span><br></pre></td></tr></table></figure><p>LCA(3, 5) = <code>4</code></p><p>LCA(5, 6) = <code>7</code></p><p>LCA(6, 7) = <code>7</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode A, TreeNode B)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span> || A == root || B == root)<span class="keyword">return</span> root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, A, B);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, A, B);</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(left != <span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果root就是A或者B,那么下面就不用遍历了，因为如果另一个在root的左右子树，那么最低的肯定是root</p><p>如果root不是A或者B,那么要考察左右子树，如果左右子树都不空，则root就是最低的。</p><p>如果左空右不空，那么右边有A或者B的或者两个都有。</p><p>如果右空左不空，那么左边是有A或者B或者两个都有。</p><p>如果两个都空，那么这颗树没有A或者B.则返回不了咯。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文总结了关于二叉树的相关题目。&lt;/p&gt;
&lt;h4 id=&quot;先序遍历&quot;&gt;&lt;a href=&quot;#先序遍历&quot; class=&quot;headerlink&quot; title=&quot;先序遍历:&quot;&gt;&lt;/a&gt;先序遍历:&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;Divide &amp;amp; Conquer  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;preorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(root == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.add(root.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; left = preorderTraversal(root.left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        List&amp;lt;Integer&amp;gt; right = preorderTraversal(root.right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.addAll(left);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.addAll(right);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ol&gt;
&lt;li&gt;Traverse  &lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt; &lt;span class=&quot;title&quot;&gt;preorderTraversal&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ArrayList&amp;lt;Integer&amp;gt; result = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ArrayList&amp;lt;Integer&amp;gt;();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        traverse(root, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;traverse&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(TreeNode root, ArrayList&amp;lt;Integer&amp;gt; result)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (root == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        result.add(root.val);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        traverse(root.left, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        traverse(root.right, result);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Tree" scheme="https://hzjry123.github.io/tags/Tree/"/>
    
      <category term="Algorithm" scheme="https://hzjry123.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>cost function</title>
    <link href="https://hzjry123.github.io/2018/01/19/cost-function/"/>
    <id>https://hzjry123.github.io/2018/01/19/cost-function/</id>
    <published>2018-01-20T03:03:37.000Z</published>
    <updated>2018-03-03T06:26:37.677Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cost-Function与Gradient-Descent"><a href="#Cost-Function与Gradient-Descent" class="headerlink" title="Cost Function与Gradient Descent"></a>Cost Function与Gradient Descent</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h2><p>为了在假设空间中选取最优的模型，引入了损失函数和风险函数，损失函数度量模型一次预测的好坏，风险函数度量了平均意义下模型预测的好坏。</p><a id="more"></a><p>我们知道监督学习是在假设空间里选出模型$f$作为决策函数，对于给定的输入x，由$f(x)$给出相应的$Y$，这个输出值可能与真实值不一致，因此需要有一个损失函数（cost function）去度量错误的程度。</p><p>常见的损失函数有如下几种：</p><ol><li><p>0-1 loss function:</p><script type="math/tex; mode=display">L(Y,f(x))=\begin{equation}\left\{             \begin{array}{lr}             1, & Y\neq f(x)\\             0, & Y= f(x)\\\end{array}\right.\end{equation}</script></li><li><p>平方损失函数:</p><script type="math/tex; mode=display">L(Y,f(X))=(Y-f(X))^2</script></li><li><p>绝对值损失函数:</p><script type="math/tex; mode=display">L(Y,f(X))=|Y-f(x)|</script></li><li><p>对数损失函数(对数似然损失函数)</p><script type="math/tex; mode=display">L(Y,P(Y|X))=-logP(Y|X)</script><p>损失函数值越小，模型越好。</p></li></ol><h2 id="2-应用线性回归"><a href="#2-应用线性回归" class="headerlink" title="2. 应用线性回归"></a>2. 应用线性回归</h2><p><img src="/2018/01/19/cost-function/linear.png" alt=""></p><p>线性回归：$y=\theta_0+ \theta_1x$</p><p>我们首先看看在线性回归中，损失函数是如何应用的，我们选择了最简单的一元线性回归。在这里选择了<strong>平方损失函数</strong>，损失函数如下：</p><script type="math/tex; mode=display">J(\theta_0, \theta_1) = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left ( \hat{y}_{i}- y_{i} \right)^2 = \dfrac {1}{2m} \displaystyle \sum _{i=1}^m \left (h_\theta (x_{i}) - y_{i} \right)^2</script><p>​    参数解释：求出每个训练样本的平方损失值并求和，其中$\hat{y}<em>{i},h</em>\theta (x<em>{i})$是预测值，$y</em>{i} $是真实值。</p><p>​    m是训练样本的数量。数量越多误差越大，所以平滑一下。2则是在求解偏导中会约分的值，为了让下降更平滑。</p><h3 id="最简单的情况："><a href="#最简单的情况：" class="headerlink" title="最简单的情况："></a>最简单的情况：</h3><p>当我们有训练样本(1,1),(2,2),(3,3)，并选择$\theta_0=0$，只考虑$\theta_1(斜率)$的变化对于损失函数值的影响。如下图：</p><p><img src="/2018/01/19/cost-function/损失函数解释.png" alt=""></p><p>其中左图是训练样本和斜率=1，0.5，0时的情况，右图是损失函数的值。</p><p>求出右图的公式非常简单:</p><script type="math/tex; mode=display">J=\frac{14(\theta_1-1)^2}{6}</script><p>通过简单的计算我们可以得知$J(1)=0,J(0)=2.3$，观察右图中损失函数的值，我们可以知道，损失函数最优的情况是当斜率为1时，损失=0，由于是只考察单个参数，所以呈抛物线的形状。</p><p>当斜率越往1靠近时，损失值就越小。</p><h3 id="稍复杂的情况"><a href="#稍复杂的情况" class="headerlink" title="稍复杂的情况"></a>稍复杂的情况</h3><p>当我们将$\theta_0$也考虑进来的时候，损失函数就不是一个抛物线这么简单了。会呈现一个碗形。</p><p><img src="/2018/01/19/cost-function/bow.png" alt=""></p><p>那这个时候我们怎么求解到损失函数的最小值呢？接下来就要使用一种梯度下降的方式。梯度下降在很多情况下都是十分有用的。</p><h2 id="损失函数求解：Gradient-descent"><a href="#损失函数求解：Gradient-descent" class="headerlink" title="损失函数求解：Gradient descent"></a>损失函数求解：Gradient descent</h2><p>Big picture：梯度下降是用来得到损失函数的local minimum的，我们应该沿着值下降的路线走，即我们应该沿着斜率为负的方向走。</p><p>intuition：沿着损失函数下降的方向走路，每次跨出的步长/梯度都不一样</p><p>梯度下降的公式：</p><script type="math/tex; mode=display">\theta_1:=\theta_1-\alpha \frac{d}{d\theta_1} J(\theta_1)</script><p><strong>参数解释：</strong>$\alpha$，学习速率；$\theta_1$，参数；$ \frac{d}{d\theta_1} J(\theta_1)d$，求偏导。</p><p>从公式我们可以看出，步长项$\alpha \frac{d}{d\theta_1} J(\theta_1)$是取了损失函数对某个参数的偏导数再乘上$\alpha$，学习速率，取负号，加上原来的值。</p><p><strong>参数更新</strong>：</p><p>用Gradient descent求解Linear Regression的系数</p><script type="math/tex; mode=display">\begin{align*} \text{repeat until convergence: } \lbrace & \newline \theta_0 := & \theta_0 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}(h_\theta(x_{i}) - y_{i}) \newline \theta_1 := & \theta_1 - \alpha \frac{1}{m} \sum\limits_{i=1}^{m}\left((h_\theta(x_{i}) - y_{i}) x_{i}\right) \newline \rbrace& \end{align*}</script><p>在这里要注意参数$\theta_1,\theta_0$是同时更新的:</p><p><a href=""><img src="/2018/01/19/cost-function/update.png" alt=""></a></p><p><strong>为什么要取负号的intuition：</strong>由于梯度下降是要找到local minimum。</p><p><img src="/2018/01/19/cost-function/抛物线.png" alt=""></p><p>所以如图</p><ul><li>如果斜率是正的，那应该减小$\theta_1$，因此加上负号，步长变负。</li><li>如果斜率是负的，那应该增大$\theta_1$，因此加上符合，步长变正。</li></ul><p><strong>关于步长的长度</strong>：步长与斜率正相关。</p><p>步长长度由$\alpha$和$|斜率|$决定，$|斜率|$越大的地方，离local minimum必然越远，因此步长应该大大，而在$|斜率|$越小的地方，离local minimum必然越近，因此步长应该较小。在这我们不用去更改学习速率，因为$|斜率|$本身告诉了我们步长的幅度应该是多大。</p><p><strong>关于$\alpha$的大小：</strong></p><p><img src="/2018/01/19/cost-function/步长大.png" alt=""></p><p>如果$\alpha$过大，那么步长相应的会变大，下山太快就找不到最低处，可能找不到这样有可能会跨过local minimum，甚至无法拟合。</p><p><img src="/2018/01/19/cost-function/步长小.png" alt=""></p><p>如果$\alpha$过小，那么步长相应的会变小，下山太慢时间太久，这样下降速度会变慢，算法效率很低。</p><p>梯度下降的起点：</p><p>梯度下降的起点（一般选参数都为0开始）选择不同，结果也会不同：</p><p><img src="/2018/01/19/cost-function/gradient.png" alt=""></p><p><img src="/2018/01/19/cost-function/gradient2.png" alt=""></p><p>这也是我比较困惑的地方。</p><p>算法复杂度：$O(mn)$ m: train data size, n: 特征数量+1</p><p><strong>训练数据大小对于梯度下降的影响：</strong>在这种梯度下降的方法(batch Gradient Descent)中，我们使用所有的训练数据去进行每次计算，因此如果训练数据过大，即m过大，计算时间很长。</p><p>因此有人提出了一个梯度下降算法的改进版SGD(随机梯度下降)。重点在随机上，该算法在每次计算梯度的时候只随机选取部分数据来计算，涉及参数miniBatchSize，定义了抽样的数据比例，为了保证所有数据都参与了计算，miniBatchSize * iteration最好 &gt; 1.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>损失函数是用来度量在某组参数下，模型的好坏程度，反过来也是我们用来选择参数的方法，而这个参数的选择是无限种可能的，因此我们必须选择一种理性的方法去得到最优的参数—— 梯度下降。梯度下降中参数会往损失函数减小的方向改变，直到到达local minimum为止。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h2><p> <a href="https://www.jianshu.com/p/1e7558e18e73" target="_blank" rel="noopener">https://www.jianshu.com/p/1e7558e18e73</a></p><p>Andrew Ng. Machine Learning.</p><p>李航《统计方法学》.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cost-Function与Gradient-Descent&quot;&gt;&lt;a href=&quot;#Cost-Function与Gradient-Descent&quot; class=&quot;headerlink&quot; title=&quot;Cost Function与Gradient Descent&quot;&gt;&lt;/a&gt;Cost Function与Gradient Descent&lt;/h1&gt;&lt;h2 id=&quot;1-定义&quot;&gt;&lt;a href=&quot;#1-定义&quot; class=&quot;headerlink&quot; title=&quot;1. 定义&quot;&gt;&lt;/a&gt;1. 定义&lt;/h2&gt;&lt;p&gt;为了在假设空间中选取最优的模型，引入了损失函数和风险函数，损失函数度量模型一次预测的好坏，风险函数度量了平均意义下模型预测的好坏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>three elements</title>
    <link href="https://hzjry123.github.io/2018/01/19/three-elements/"/>
    <id>https://hzjry123.github.io/2018/01/19/three-elements/</id>
    <published>2018-01-19T12:10:49.000Z</published>
    <updated>2018-03-03T05:10:24.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="统计方法三要素"><a href="#统计方法三要素" class="headerlink" title="统计方法三要素"></a>统计方法三要素</h1><p>在《统计学方法》一书中，作者将统计学算法表达为如下公式（1）</p><p>其中</p><ol><li>模型就是所要学习的条件概率分布或决策函数。</li><li>策略就是用损失函数（cost function/loss function）来度量预测错误程度算法就是求解过程</li><li>算法就是求解模型的办法。</li></ol><script type="math/tex; mode=display">方法=模型+策略+算法</script><p>按照我的理解：</p><ol><li>模型：找到一个合适的预测函数$h(\theta)$，用来预测输入的数据的判断结果，需要到数据和结果有一个分析和了解，明确问题，知道$h(\theta)$的大概形式。</li><li>构造一个损失函数$J(\theta)$，表示预测$\hat y$与训练数据的真实值$y$的偏差。可以是求差值或者是求对数损失。综合考虑所有训练数据的损失，</li><li>显然，$J(\theta)$的值越小，$h(\theta)$的越准确，所以我们显然要找到$J(\theta)$的最小值。我们一般使用的方法有梯度下降。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;统计方法三要素&quot;&gt;&lt;a href=&quot;#统计方法三要素&quot; class=&quot;headerlink&quot; title=&quot;统计方法三要素&quot;&gt;&lt;/a&gt;统计方法三要素&lt;/h1&gt;&lt;p&gt;在《统计学方法》一书中，作者将统计学算法表达为如下公式（1）&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;ol&gt;

      
    
    </summary>
    
    
      <category term="机器学习" scheme="https://hzjry123.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于hexo的next主题无法显示latex公式</title>
    <link href="https://hzjry123.github.io/2018/01/18/%E5%85%B3%E4%BA%8Ehexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BAlatex%E5%85%AC%E5%BC%8F/"/>
    <id>https://hzjry123.github.io/2018/01/18/关于hexo的next主题无法显示latex公式/</id>
    <published>2018-01-18T11:50:41.000Z</published>
    <updated>2018-01-19T01:15:24.252Z</updated>
    
    <content type="html"><![CDATA[<p>reference: <a href="http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/#%E5%B0%8F%E7%BB%93" target="_blank" rel="noopener">http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/#%E5%B0%8F%E7%BB%93</a></p><p>Thanks 林肯先生</p><p>在next里写latex时发现渲染不出来，查找后发现是说node.js的渲染和markdown渲染的问题。操作半天也不得行。</p><p>但我发现我是什么公式也渲染不出来啊！后来在next的issue里面查找相关问题，发现得先在/themes/next/_config.yml里把third-party-services settings中的math设置为enable</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>感觉被自己蠢到了。</p><p>但是这样设置以后还是不行，参考了”林肯先生”的做法。</p><ol><li><code>npm uninstall hexo-renderer-marked --save</code>//先删除原先的markdown渲染工具</li><li><code>npm install hexo-renderer-kramed --save</code>//安装新的markdown渲染工具</li></ol><p>由于markdown在渲染时”_ “会被认为是下划线，和latex下标的操作一样，会先渲染markdown的，导致latex无法渲染，因此要在里面加\把_转义，到这个时候才和”林肯先生”的问题一样，我有点震惊。</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$R<span class="string">\_&#123;m</span> <span class="string">\times</span> n&#125; = U<span class="string">\_&#123;m</span> <span class="string">\times</span> m&#125; S<span class="string">\_&#123;m</span> <span class="string">\times</span> n&#125; V<span class="string">\_&#123;n</span> <span class="string">\times</span> n&#125;<span class="string">'$</span></span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">R\_{m \times n} = U\_{m \times m} S\_{m \times n} V\_{n \times n}'</script><p>很强，但是能用了，饿死了先去吃饭了，如果有哪位朋友知道这该怎么办，请告诉我一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;reference: &lt;a href=&quot;http://2wildkids.com/2016/10/06/%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86Hexo%E5%92%8CMathJax%E7%9A%84%E5%85%BC%E5%AE%B9%E
      
    
    </summary>
    
    
      <category term="hexo" scheme="https://hzjry123.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Maximum Product subarray</title>
    <link href="https://hzjry123.github.io/2018/01/17/Maximum-Product-subarray/"/>
    <id>https://hzjry123.github.io/2018/01/17/Maximum-Product-subarray/</id>
    <published>2018-01-18T04:48:06.000Z</published>
    <updated>2018-01-19T00:49:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="152-Maximum-Product-SubaArray"><a href="#152-Maximum-Product-SubaArray" class="headerlink" title="152.Maximum-Product-SubaArray"></a>152.Maximum-Product-SubaArray</h1><h2 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description:"></a>1. Description:</h2><p>Find the contiguous subarray within an array (containing at least one number) which has the largest product.</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">For example, given the array[<span class="number">2</span>,<span class="number">3</span>,<span class="number">-2</span>,<span class="number">4</span>]`,</span><br><span class="line"></span><br><span class="line">the contiguous subarray [<span class="number">2</span>,<span class="number">3</span>] has the largest product = <span class="number">6.</span></span><br></pre></td></tr></table></figure><h3 id="2-Difficulty"><a href="#2-Difficulty" class="headerlink" title="2. Difficulty:"></a>2. Difficulty:</h3><p>Medium</p><h3 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution:"></a>3. Solution:</h3><a id="more"></a><p>It remains us of Maximum-Sum-SubArray, but it is more complicated</p><p>First I came up with a brute $O(n^2)$ solution.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length,max = nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>)<span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[][] product = <span class="keyword">new</span> <span class="keyword">int</span>[len][len];</span><br><span class="line">        product[len - <span class="number">1</span>][len - <span class="number">1</span>] = nums[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            product[i][i] = nums[i];</span><br><span class="line">            max = Math.max(max,nums[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                product[i][j] = nums[i] * product[i + <span class="number">1</span>][j];</span><br><span class="line">                max = Math.max(max,product[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>But it failed to pass OJ.</p><p>解法一：</p><p>Then I came up with another <strong>Dynamic Programming</strong> Solution.</p><p>我们知道在乘法中，只要乘数不包括0，那么结果在绝对值上也会变大，因此我们要追踪的是当前的最大以及最小值，这两者理论上都有可能在后面变成最大乘积。</p><p>参考Discuss上的一段话</p><blockquote><p>Besides keeping track of the largest product, we also need to keep track of the smallest product. Why? The smallest product, which is the largest in the negative sense could become the maximum when being multiplied by a negative number.</p></blockquote><p>但是我们要保证一点，就是在循环到nums[i]处时，当前步骤的最大值必须是受到nusm[i-1]影响的。在得到最大最小值时，我们要比较的是nums[i]和上一步的最大最小值的乘积以及当前nums[i].</p><p>因此在nums[i] &gt; 0时，我们可以得到转移方程:</p><script type="math/tex; mode=display">max[i] = Math.max(max[i - 1] * nums[i],nums[i])</script><script type="math/tex; mode=display">min[i] = Math.max(min[i-1]*nums[i],nums[i])</script><p>在nums[i] &lt; 0 时，我们可以得到转移方程</p><script type="math/tex; mode=display">max[i] = Math.max(min[i - 1] * nums[i],nums[i])</script><script type="math/tex; mode=display">min[i] = Math.max(max[i-1]*nums[i],nums[i])</script><p>在得到最后的最大值时只需遍历max数组即可。</p><p>在空间上优化：用变量max，min代替数组，每步都获得当前的最大值。</p><script type="math/tex; mode=display">cur\\_max =Math.max(cur\\_max,max)</script><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_n</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>],max = res,min = res,len = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            max = Math.max(nums[i] * max, nums[i]);</span><br><span class="line">            min = Math.min(nums[i] * min, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = max;</span><br><span class="line">            max = Math.max(min * nums[i],nums[i]);</span><br><span class="line">            min = Math.min(temp * nums[i],nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res,max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二: </p><p>解法一代码简化。</p><p>从上一步我们可以看出，max和min的值是交换的。即在nums &lt;= 0的时候，max和min就会发生互换。因此我们可以加入一个判断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(nums[i] =&lt; <span class="number">0</span>) swap(max,min);</span><br><span class="line"> max = Math.max(nums[i] * max, nums[i]);</span><br><span class="line">    min = Math.min(nums[i] * min, nums[i]);</span><br></pre></td></tr></table></figure><p>解法三:</p><p>由于是乘法，考虑没有0的情况，每加入一个新的数，乘积的绝对值都会变大，如果整个数组有n个负数</p><p>若n为偶，则subarray就是全部array。</p><p>若n为奇，则可以得到负数为偶数个的subarray来比较乘积</p><p>头尾是正，如[2,3,-4,1,2]  就是[2,3] 和 [1,2]的比较。</p><p>头尾是负，[-4,1,-2,3,-4]就是[-4,1,-2,3],[1,-2,3,-4]。</p><p>头是正[1,-1,-3,3,-2]就是[1,-1,-3,3]</p><p>尾是正[-1,-1,-3,3,2]就是[-1,-3,3,2]</p><p>由此其实可以直观感觉出，如果有最大值的话，那么最大值一定是会包括头或者尾的。</p><p>故可以遍历两边，从头遍历一遍，从尾遍历一遍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxProduct_n</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = nums[<span class="number">0</span>],len = nums.length,product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">      product *= nums[i];</span><br><span class="line">        res = Math.max(res,product);</span><br><span class="line">      <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)product = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  product = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">      product *= nums[i];</span><br><span class="line">        res = Math.max(res,product);</span><br><span class="line">      <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)product = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;152-Maximum-Product-SubaArray&quot;&gt;&lt;a href=&quot;#152-Maximum-Product-SubaArray&quot; class=&quot;headerlink&quot; title=&quot;152.Maximum-Product-SubaArray&quot;&gt;&lt;/a&gt;152.Maximum-Product-SubaArray&lt;/h1&gt;&lt;h2 id=&quot;1-Description&quot;&gt;&lt;a href=&quot;#1-Description&quot; class=&quot;headerlink&quot; title=&quot;1. Description:&quot;&gt;&lt;/a&gt;1. Description:&lt;/h2&gt;&lt;p&gt;Find the contiguous subarray within an array (containing at least one number) which has the largest product.&lt;/p&gt;
&lt;figure class=&quot;highlight lsl&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;For example, given the array[&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;-2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;]`,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;the contiguous subarray [&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;] has the largest product = &lt;span class=&quot;number&quot;&gt;6.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;2-Difficulty&quot;&gt;&lt;a href=&quot;#2-Difficulty&quot; class=&quot;headerlink&quot; title=&quot;2. Difficulty:&quot;&gt;&lt;/a&gt;2. Difficulty:&lt;/h3&gt;&lt;p&gt;Medium&lt;/p&gt;
&lt;h3 id=&quot;3-Solution&quot;&gt;&lt;a href=&quot;#3-Solution&quot; class=&quot;headerlink&quot; title=&quot;3. Solution:&quot;&gt;&lt;/a&gt;3. Solution:&lt;/h3&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://hzjry123.github.io/tags/LeetCode/"/>
    
      <category term="DynamicProgramming" scheme="https://hzjry123.github.io/tags/DynamicProgramming/"/>
    
  </entry>
  
  <entry>
    <title>461. Hamming Distance</title>
    <link href="https://hzjry123.github.io/2017/11/27/461-Hamming-Distance/"/>
    <id>https://hzjry123.github.io/2017/11/27/461-Hamming-Distance/</id>
    <published>2017-11-27T06:03:28.000Z</published>
    <updated>2018-01-18T17:46:14.701Z</updated>
    
    <content type="html"><![CDATA[<h1 id="461-Hamming-Distance"><a href="#461-Hamming-Distance" class="headerlink" title="461. Hamming Distance"></a>461. Hamming Distance</h1><h3 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description:"></a>1. Description:</h3><p>The <a href="https://en.wikipedia.org/wiki/Hamming_distance" target="_blank" rel="noopener">Hamming distance</a> between two integers is the number of positions at which the corresponding bits are different.</p><p>Given two integers <code>x</code> and <code>y</code>, calculate the Hamming distance.</p><p><strong>Note:</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p><p><strong>Example:</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Input</span>: x = 1, y = 4</span><br><span class="line"></span><br><span class="line"><span class="attribute">Output</span>: 2</span><br><span class="line"></span><br><span class="line"><span class="attribute">Explanation:</span></span><br><span class="line">1   (0 0 0 1)</span><br><span class="line">4   (0 1 0 0)</span><br><span class="line">       ↑   ↑</span><br><span class="line"></span><br><span class="line">The above arrows point to positions where the corresponding bits are different.</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="2-Difficulty"><a href="#2-Difficulty" class="headerlink" title="2. Difficulty:"></a>2. Difficulty:</h3><p>Easy</p><h3 id="3-Solution"><a href="#3-Solution" class="headerlink" title="3. Solution:"></a>3. Solution:</h3><h4 id="bit-count"><a href="#bit-count" class="headerlink" title="bit count"></a>bit count</h4><p>What does come to your mind first when you see this sentence <code>&quot;corresponding bits are different&quot;</code>? Yes, <code>XOR</code>! Also, do not forget there is a decent function Java provided: <code>Integer.bitCount()</code> ~~~</p><p>But how does bitcount work?</p><p>Let us look at the source code</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// HD, Figure 5-2</span></span><br><span class="line"><span class="comment">//        java 逐位运算符</span></span><br><span class="line"><span class="comment">//        逐位或运算符(|),右移运算符(&gt;&gt;)非运算符(~) ,用0补足的右移运算符(&gt;&gt;&gt;)</span></span><br><span class="line">        i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br><span class="line">        i = i + (i &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">        i = i + (i &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> i &amp; <span class="number">0x3f</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>hex: 0x55555555, hex 5: 0101</p><p>binary: 101 0101 0101 0101 0101 0101 0101 0101</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i - ((i &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br></pre></td></tr></table></figure><p>第一行是计算每两位中的 1 的个数 , 并且用该对应的两位来存储这个个数 ,<br>如 : 01101100 -&gt; 01011000 , 即先把前者每两位分段 01 10 11 00 , 分别有 1 1 2 0 个 1, 用两位二进制数表示为 01 01 10 00, 合起来为 01011000.</p><p>Count the number of 1 in every two digits, and use two digits to store it.</p><p>e.g. 01 10 11 00 store in 01 01 10 00.</p><p>By <code>(i &gt;&gt;&gt; 1)</code>  e.g. <code>01 10 &gt;&gt;&gt; 1</code> = <code>00 11</code> , <code>00 11 &amp; 0x5(01 01)</code> = <code>00 01</code> . We get the number of 1 in high digit in <code>01 10</code> . </p><ul><li>In first two digits<code>01</code>, the number of 1 in high digit is 0.</li></ul><ul><li>In second two digits<code>10</code>, the number of 1 in high digit is 1.</li></ul><p>Then how to get total number of every 2 digits?</p><p>All cases:</p><p> <code>11</code> , <code>i &gt;&gt;&gt; 1</code> = <code>1</code> , <code>1 &amp; 0101</code> = <code>1</code> . We suppose to get <code>10</code> . And  <code>11 - 1</code> = <code>10</code> .</p><p> <code>10</code> , <code>i &gt;&gt;&gt; 1</code> = <code>1</code> , <code>1 &amp; 0101</code> = <code>1</code> . We suppose to get <code>01</code> . And  <code>10 - 1</code> = <code>01</code> .</p><p> <code>01</code> , <code>i &gt;&gt;&gt; 1</code> = <code>0</code> , <code>0 &amp; 0101</code> = <code>0</code> . We suppose to get <code>01</code> . And  <code>01 - 0</code> = <code>01</code> .</p><p> <code>00</code> , <code>i &gt;&gt;&gt; 1</code> = <code>0</code> , <code>0 &amp; 0101</code> = <code>0</code> . We suppose to get <code>00</code> . And  <code>00 - 0</code> = <code>00</code> .</p><p>So <code>i - 00 01</code> = <code>01 10 - 00 01</code> = <code>01 10</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i &amp; <span class="number">0x33333333</span>) + ((i &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br></pre></td></tr></table></figure><p><code>0x33333333</code> = <code>0011 0011 0011…</code></p><p>第二行是计算每四位中的 1 的个数 , 并且用该对应的四位来存储这个个数 .<br>如 : 01101100 经过第一行计算后得 01011000 , 然后把 01011000 每四位分段成 0101 1000 , 段内移位相加 : 前段01+01 =10 , 后段 10+00=10, 分别用四位二进制数表示为 0010 0010, 合起来为 00100010 .</p><p>After counting every two digits. We should count every 4 digits.</p><p>It is quite same like count every two digits. Try it!</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = (i + (i &gt;&gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0x0f0f0f0f</span>;</span><br></pre></td></tr></table></figure><p><code>0f0f0f0f</code> = <code>0000 1111 0000 1111 0000 1111</code></p><p>After count 4 digits. We count 8 digits.</p><p>We still check 16digits and 32 digits.</p><h3 id="other-solution1"><a href="#other-solution1" class="headerlink" title="other solution1:"></a>other solution1:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance_2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        对于一个正整数如果是偶数，该数的二进制数的最后一位是 0 ，</span></span><br><span class="line"><span class="comment">// 反之若是奇数，则该数的二进制数的最后一位是 1 。因此，可以考虑利用位移、判断奇偶来实现。</span></span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (xor != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((xor &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            xor = xor &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="other-solution2"><a href="#other-solution2" class="headerlink" title="other solution2:"></a>other solution2:</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingDistance_3</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 计算 1 的个数，若让算法的运算次数只与“ 1 ”的个数有关，那复杂度就能进一步降低。</span></span><br><span class="line"><span class="comment">// 思想： x &amp; (x-1) 可以消去 x 二进制数的最后一位 1</span></span><br><span class="line">        <span class="keyword">int</span> xor = x ^ y;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (xor != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            xor &amp;= xor - <span class="number">1</span>;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><a href="http://15838341661-139-com.iteye.com/blog/1642525" target="_blank" rel="noopener">http://15838341661-139-com.iteye.com/blog/1642525</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;461-Hamming-Distance&quot;&gt;&lt;a href=&quot;#461-Hamming-Distance&quot; class=&quot;headerlink&quot; title=&quot;461. Hamming Distance&quot;&gt;&lt;/a&gt;461. Hamming Distance&lt;/h1&gt;&lt;h3 id=&quot;1-Description&quot;&gt;&lt;a href=&quot;#1-Description&quot; class=&quot;headerlink&quot; title=&quot;1. Description:&quot;&gt;&lt;/a&gt;1. Description:&lt;/h3&gt;&lt;p&gt;The &lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_distance&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hamming distance&lt;/a&gt; between two integers is the number of positions at which the corresponding bits are different.&lt;/p&gt;
&lt;p&gt;Given two integers &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, calculate the Hamming distance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;br&gt;0 ≤ &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; &amp;lt; 231.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Input&lt;/span&gt;: x = 1, y = 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Output&lt;/span&gt;: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;Explanation:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1   (0 0 0 1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4   (0 1 0 0)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ↑   ↑&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;The above arrows point to positions where the corresponding bits are different.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://hzjry123.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Largest Rectangle in Histogram</title>
    <link href="https://hzjry123.github.io/2017/11/20/Largest-Rectangle-in-Histogram/"/>
    <id>https://hzjry123.github.io/2017/11/20/Largest-Rectangle-in-Histogram/</id>
    <published>2017-11-20T08:08:54.000Z</published>
    <updated>2017-11-22T02:52:20.617Z</updated>
    
    <content type="html"><![CDATA[<h1 id="84-Largest-Rectangle-in-Histogram"><a href="#84-Largest-Rectangle-in-Histogram" class="headerlink" title="84. Largest Rectangle in Histogram"></a>84. Largest Rectangle in Histogram</h1><p><strong>Reference</strong>: <a href="http://www.geeksforgeeks.org/largest-rectangle-under-histogram/" target="_blank" rel="noopener">http://www.geeksforgeeks.org/largest-rectangle-under-histogram/</a></p><h3 id="1-Description"><a href="#1-Description" class="headerlink" title="1. Description:"></a><strong>1</strong>. Description:</h3><p>Given <em>n</em> non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.</p><p><img src="https://leetcode.com/static/images/problemset/histogram.png" alt="img"></p><p>Above is a histogram where width of each bar is 1, given height = <code>[2,1,5,6,2,3]</code>.</p><p><img src="https://leetcode.com/static/images/problemset/histogram_area.png" alt="img"></p><p>The largest rectangle is shown in the shaded area, which has area = <code>10</code> unit.</p><a id="more"></a><h3 id="2-Difficulty"><a href="#2-Difficulty" class="headerlink" title="2. Difficulty:"></a>2. Difficulty:</h3><p>Hard</p><h3 id="3-Relative-Problems"><a href="#3-Relative-Problems" class="headerlink" title="3. Relative Problems"></a>3. Relative Problems</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">85. </span>Maximal Rectangle</span><br><span class="line"><span class="bullet">221. </span>Maximal Square</span><br></pre></td></tr></table></figure><h3 id="4-Solution"><a href="#4-Solution" class="headerlink" title="4. Solution:"></a>4. Solution:</h3><p><strong>Analysis</strong>: How to get a Largest Rectangle?  The problems sounds like buckets effect. The main idea is to find <strong>the height with its longest width</strong>. But How to do this in one pass?</p><p>When we observe the graph above, the first height 2 can only have width 1. Because the right height is 1. It is easy to see 1 <strong>depend on</strong> the <strong>buckets height</strong>. </p><p>When we look at 1, its longest width is 6. <code>[2,1,5,6,2,3]</code>.</p><p>When we look at 5, its longest width is 2.  <code>5,6</code></p><p>When we look at 6, its longest width is 1.  <code>6</code></p><p>When we look at 2, its longest width is 4.  <code>5,6,2,3</code> </p><p>When we look at 3, its longest width is 1.  <code>3</code> </p><p>So if we want to get the <strong>longest width</strong>. We should find the <strong>bars whose height are lower than it !</strong>(both left bound and right bound).</p><p>For 2, we get left bound 1. So we get  the largest bucket for 2 <code>2</code> .</p><p>For 5, we get left bound 1, right bound 2. So we get  the largest bucket for 5 <code>5,6</code> .</p><p>For 6, we get left bound 5, right bound 2. So we get the largest bucket for 6 <code>6</code>.</p><p>For 2, we get left bound 1, right bound 0 (consider histgram[length] = 0). So we get the largest bucket for 2. <code>5,6,2,3</code> </p><p>Now let’s discuss how to <strong>get the bound</strong>.</p><p>Look at our requirement. One <strong>pass</strong>, <strong>get longest width for higher height</strong>. </p><p>As we analysize above, after getting 6’s width, 6 is useless, it could be 5,6,7 whatever &gt;= 5. </p><p>After get 5’s width, 5 is useless. Because we know that all the rest of height is smaller than 5.</p><p>So We could use <strong>stack</strong> of  ascendent order ( bottom to top )  to solve this problem. </p><h3 id="Stack-Solution"><a href="#Stack-Solution" class="headerlink" title="Stack Solution:"></a>Stack Solution:</h3><p>In stack, I store index.</p><p>For corner case, I set <strong>leftmost</strong> and <strong>rightmost</strong> height as 0.</p><p>According to our analysis above, we just need to get higher height. So if the top of stack is smaller than the new height. We should push new height into stack. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(stack.empty() || heights[stack.peek()] &lt;= h)</span><br><span class="line">  stack.push(i);</span><br></pre></td></tr></table></figure><p>Else, which means the current bucket’s height can not  get longer width, we should pop top out and get its max Area. At this moment, we get the <strong>right bound</strong>. </p><p>What is its <strong>left bound</strong>? The <strong>current top</strong> of stack !</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">maxArea = Math.max(maxArea,</span><br><span class="line">                   heights[cur] * (stack.empty()? i :(i - stack.peek() - <span class="number">1</span>)));</span><br><span class="line">i--;</span><br></pre></td></tr></table></figure><p>But we didn’t push the right bound into stack, so we need current  i in next iteration. So  <code>i- -</code> .</p><p><strong>Code</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.length; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> h = i == heights.length? <span class="number">0</span> : heights[i];</span><br><span class="line">        <span class="keyword">if</span>(stack.empty() || heights[stack.peek()] &lt;= h)&#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">              <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">                maxArea = Math.max(maxArea,</span><br><span class="line">                        heights[cur] * (stack.empty()? i :(i - stack.peek() - <span class="number">1</span>)));</span><br><span class="line">                i--;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> maxArea;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();<span class="comment">//栈中元素只会更大</span></span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= heights.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> h = i == heights.length? <span class="number">0</span> : heights[i];</span><br><span class="line">            <span class="keyword">if</span>(stack.empty() || heights[stack.peek()] &lt;= h)&#123;</span><br><span class="line">                <span class="comment">//停止条件就是 栈空时，遍历完全部。</span></span><br><span class="line">                <span class="comment">//此步骤是为了获得高度更高的木桶，为什么要得到高度更高的木桶呢?因为决定面积的是木桶高度和宽度。</span></span><br><span class="line">                <span class="comment">//我们在不断的得到更大的宽度的同时，要选择更好的木桶高度。如果是4 3 2 这种木桶</span></span><br><span class="line">                <span class="comment">//当我们无法以更高的高度作为高度时，例如4.那把4放在栈中就没有意义了。</span></span><br><span class="line">                <span class="comment">//遍历他也没用啊。以2作为高度，自然可以得到最大的面积。</span></span><br><span class="line">                <span class="comment">//因为后面的事情与他无关，不管你是6 7 8 还是多少也好，决定木桶高度的永远是小的那块木板。</span></span><br><span class="line">                <span class="comment">//若此时栈顶的高度小于要加入的高度，那么根据木桶理论。</span></span><br><span class="line">                <span class="comment">//前面的高度会失效，在失效前我们必须计算以他为高度的木桶面积。else部分</span></span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//此时栈顶是上一个比他小的元素的位置，即我们的木桶的左边界，i是我们木桶的右边界</span></span><br><span class="line">                <span class="comment">//那么计算木桶的宽度 i - top - 1。比较面积</span></span><br><span class="line">                <span class="keyword">int</span> cur = stack.pop();</span><br><span class="line">                maxArea = Math.max(maxArea,</span><br><span class="line">                        heights[cur] * (stack.empty()? i :(i - stack.peek() - <span class="number">1</span>)));</span><br><span class="line">                i--;</span><br><span class="line">                <span class="comment">//这一步就是为了让此时的这个木板，再次去和栈顶进行比较，我们不能直接入栈。因为我们的栈是从小到大的。</span></span><br><span class="line">                <span class="comment">//即为了保证我们总能得到大的木桶高度。</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//i == length怎么办? 我们在栈中剩余的，就是他可以达到的最大宽度的地方。即我们获得了栈的高度能保证的最大宽度！</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;84-Largest-Rectangle-in-Histogram&quot;&gt;&lt;a href=&quot;#84-Largest-Rectangle-in-Histogram&quot; class=&quot;headerlink&quot; title=&quot;84. Largest Rectangle in Histogram&quot;&gt;&lt;/a&gt;84. Largest Rectangle in Histogram&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;: &lt;a href=&quot;http://www.geeksforgeeks.org/largest-rectangle-under-histogram/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.geeksforgeeks.org/largest-rectangle-under-histogram/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;1-Description&quot;&gt;&lt;a href=&quot;#1-Description&quot; class=&quot;headerlink&quot; title=&quot;1. Description:&quot;&gt;&lt;/a&gt;&lt;strong&gt;1&lt;/strong&gt;. Description:&lt;/h3&gt;&lt;p&gt;Given &lt;em&gt;n&lt;/em&gt; non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://leetcode.com/static/images/problemset/histogram.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;Above is a histogram where width of each bar is 1, given height = &lt;code&gt;[2,1,5,6,2,3]&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://leetcode.com/static/images/problemset/histogram_area.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;p&gt;The largest rectangle is shown in the shaded area, which has area = &lt;code&gt;10&lt;/code&gt; unit.&lt;/p&gt;
    
    </summary>
    
    
      <category term="LeetCode" scheme="https://hzjry123.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
